package sdkgen

// generateClient generates the client.ts file with core HTTP infrastructure types and the request function.
// SSEConnection and buildFormData are now in separate files (sse.ts, form-data.ts) for tree-shaking.
func generateClient() string {
	return `// Auto-generated by tsgonest sdk â€” do not edit

export interface SDKError {
  status: number;
  message: string;
  body?: unknown;
}

export type SDKResult<T> = { data: T; error: null; response: Response } | { data: null; error: SDKError; response: Response };

export type Fetcher = (url: string, init: RequestInit) => Promise<Response>;

export type HeadersInit = Record<string, string> | (() => Record<string, string> | Promise<Record<string, string>>);

export interface ClientConfig {
  baseUrl: string;
  headers?: HeadersInit;
  fetcher?: Fetcher;
  onRequest?: (url: string, init: RequestInit) => RequestInit | Promise<RequestInit>;
}

export type RequestFn = <T>(
  method: string,
  path: string,
  options?: {
    params?: Record<string, string>;
    query?: Record<string, unknown>;
    body?: unknown;
    headers?: Record<string, string>;
    signal?: AbortSignal;
    contentType?: string;
    responseType?: 'json' | 'blob' | 'text' | 'stream' | 'sse' | 'sse-raw';
  },
) => Promise<SDKResult<T>>;

export function createRequestFn(config: ClientConfig): RequestFn {
  const fetcher = config.fetcher ?? fetch;

  return async <T>(
    method: string,
    path: string,
    options?: {
      params?: Record<string, string>;
      query?: Record<string, unknown>;
      body?: unknown;
      headers?: Record<string, string>;
      signal?: AbortSignal;
      contentType?: string;
      responseType?: 'json' | 'blob' | 'text' | 'stream' | 'sse' | 'sse-raw';
    },
  ): Promise<SDKResult<T>> => {
    // Interpolate path params
    let url = path;
    if (options?.params) {
      for (const [key, value] of Object.entries(options.params)) {
        url = url.replace(` + "`{${key}}`" + `, encodeURIComponent(value));
      }
    }

    // Build query string
    if (options?.query) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(options.query)) {
        if (value === undefined || value === null) continue;
        if (Array.isArray(value)) {
          for (const item of value) {
            searchParams.append(key, String(item));
          }
        } else {
          searchParams.set(key, String(value));
        }
      }
      const qs = searchParams.toString();
      if (qs) url += ` + "`?${qs}`" + `;
    }

    const fullUrl = config.baseUrl.replace(/\/$/, '') + url;

    // Resolve headers
    let baseHeaders: Record<string, string> = {};
    if (config.headers) {
      if (typeof config.headers === 'function') {
        baseHeaders = await config.headers();
      } else {
        baseHeaders = config.headers;
      }
    }

    const allHeaders: Record<string, string> = {
      ...baseHeaders,
      ...options?.headers,
    };

    // Build request init
    let init: RequestInit = {
      method,
      headers: allHeaders,
      signal: options?.signal,
    };

    if (options?.body !== undefined) {
      const contentType = options?.contentType ?? 'application/json';
      if (options.body instanceof FormData) {
        // Let the browser set the Content-Type with boundary
        init.body = options.body;
      } else if (contentType === 'application/json') {
        init.body = JSON.stringify(options.body);
        allHeaders['Content-Type'] = 'application/json';
        init.headers = allHeaders;
      } else {
        init.body = String(options.body);
        allHeaders['Content-Type'] = contentType;
        init.headers = allHeaders;
      }
    }

    // onRequest hook
    if (config.onRequest) {
      init = await config.onRequest(fullUrl, init);
    }

    const response = await fetcher(fullUrl, init);

    if (!response.ok) {
      let errorBody: unknown;
      try {
        errorBody = await response.json();
      } catch {
        errorBody = await response.text().catch(() => undefined);
      }
      return {
        data: null,
        error: {
          status: response.status,
          message: response.statusText,
          body: errorBody,
        },
        response,
      };
    }

    // 204 No Content
    if (response.status === 204) {
      return { data: undefined as T, error: null, response };
    }

    // Response type hint from codegen
    const respType = options?.responseType ?? 'json';

    if (respType === 'blob') {
      const data = await response.blob() as T;
      return { data, error: null, response };
    }

    if (respType === 'stream') {
      return { data: response.body as T, error: null, response };
    }

    if (respType === 'sse' || respType === 'sse-raw') {
      // SSE handling is done by the controller via SSEConnection from sse.ts
      return { data: response as unknown as T, error: null, response };
    }

    if (respType === 'text') {
      const data = await response.text() as T;
      return { data, error: null, response };
    }

    // Default: parse based on content-type header
    const contentTypeHeader = response.headers.get('content-type') ?? '';
    if (contentTypeHeader.includes('application/json')) {
      const data = await response.json() as T;
      return { data, error: null, response };
    }

    const text = await response.text();
    return { data: text as T, error: null, response };
  };
}
`
}
