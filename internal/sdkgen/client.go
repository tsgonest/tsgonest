package sdkgen

// generateClient generates the client.ts file with infrastructure types and the request function.
func generateClient() string {
	return `// Auto-generated by tsgonest sdk â€” do not edit

export interface SDKError {
  status: number;
  message: string;
  body?: unknown;
}

export type SDKResult<T> = { data: T; error: null; response: Response } | { data: null; error: SDKError; response: Response };

export type Fetcher = (url: string, init: RequestInit) => Promise<Response>;

export type HeadersInit = Record<string, string> | (() => Record<string, string> | Promise<Record<string, string>>);

export interface ClientConfig {
  baseUrl: string;
  headers?: HeadersInit;
  fetcher?: Fetcher;
  onRequest?: (url: string, init: RequestInit) => RequestInit | Promise<RequestInit>;
}

export type RequestFn = <T>(
  method: string,
  path: string,
  options?: {
    params?: Record<string, string>;
    query?: Record<string, unknown>;
    body?: unknown;
    headers?: Record<string, string>;
    signal?: AbortSignal;
    contentType?: string;
    responseType?: 'json' | 'blob' | 'text' | 'stream' | 'sse' | 'sse-raw';
  },
) => Promise<SDKResult<T>>;

export interface SSEEvent<T> {
  data: T;
  event?: string;
  id?: string;
  retry?: number;
}

export class SSEConnection<T> {
  private reader: ReadableStreamDefaultReader<string> | null = null;
  private buffer = '';
  private closed = false;
  private lastEventId = '';
  private listeners: Map<string, Array<(event: SSEEvent<T>) => void>> = new Map();

  constructor(
    private response: Response,
    private parse: (data: string) => T,
  ) {}

  on(event: 'message' | 'error' | string, handler: (event: SSEEvent<T>) => void): this {
    const list = this.listeners.get(event) ?? [];
    list.push(handler);
    this.listeners.set(event, list);
    return this;
  }

  close(): void {
    this.closed = true;
    this.reader?.cancel();
  }

  get lastId(): string {
    return this.lastEventId;
  }

  async *[Symbol.asyncIterator](): AsyncIterableIterator<SSEEvent<T>> {
    const body = this.response.body;
    if (!body) return;

    this.reader = body.pipeThrough(new TextDecoderStream()).getReader();

    try {
      while (!this.closed) {
        const { done, value } = await this.reader.read();
        if (done) break;
        this.buffer += value;

        const parts = this.buffer.split('\n\n');
        this.buffer = parts.pop()!;

        for (const part of parts) {
          const event = this.parseEvent(part);
          if (event) {
            yield event;
            this.emit(event);
          }
        }
      }
    } finally {
      this.reader?.cancel();
    }
  }

  private parseEvent(raw: string): SSEEvent<T> | null {
    let data = '';
    let eventName: string | undefined;
    let id: string | undefined;
    let retry: number | undefined;

    for (const line of raw.split('\n')) {
      if (line.startsWith('data:')) {
        data += (data ? '\n' : '') + line.slice(5).trimStart();
      } else if (line.startsWith('event:')) {
        eventName = line.slice(6).trimStart();
      } else if (line.startsWith('id:')) {
        id = line.slice(3).trimStart();
        this.lastEventId = id;
      } else if (line.startsWith('retry:')) {
        const val = parseInt(line.slice(6).trimStart(), 10);
        if (!isNaN(val)) retry = val;
      }
    }

    if (!data) return null;

    return {
      data: this.parse(data),
      event: eventName,
      id,
      retry,
    };
  }

  private emit(event: SSEEvent<T>): void {
    const eventType = event.event ?? 'message';
    const handlers = this.listeners.get(eventType) ?? [];
    const messageHandlers = eventType !== 'message' ? (this.listeners.get('message') ?? []) : [];
    for (const h of [...handlers, ...messageHandlers]) h(event);
  }
}

export function buildFormData<T = unknown>(data: T): FormData {
  const formData = new FormData();

  function appendValue(key: string, value: unknown) {
    if (value instanceof Blob) {
      formData.append(key, value);
      return;
    }
    if (value instanceof Date) {
      formData.append(key, value.toISOString());
      return;
    }
    if (typeof value === 'number' || typeof value === 'boolean') {
      formData.append(key, String(value));
      return;
    }
    if (typeof value === 'string') {
      formData.append(key, value);
      return;
    }
    if (typeof value === 'object' && value !== null) {
      formData.append(key, new Blob([JSON.stringify(value)], { type: 'application/json' }));
      return;
    }
  }

  if (data && typeof data === 'object') {
    for (const [key, value] of Object.entries(data as Record<string, unknown>)) {
      if (value === undefined || value === null) continue;
      if (Array.isArray(value)) {
        for (const item of value) {
          if (item === undefined || item === null) continue;
          appendValue(key, item);
        }
      } else {
        appendValue(key, value);
      }
    }
  }

  return formData;
}

export function createRequestFn(config: ClientConfig): RequestFn {
  const fetcher = config.fetcher ?? fetch;

  return async <T>(
    method: string,
    path: string,
    options?: {
      params?: Record<string, string>;
      query?: Record<string, unknown>;
      body?: unknown;
      headers?: Record<string, string>;
      signal?: AbortSignal;
      contentType?: string;
      responseType?: 'json' | 'blob' | 'text' | 'stream' | 'sse' | 'sse-raw';
    },
  ): Promise<SDKResult<T>> => {
    // Interpolate path params
    let url = path;
    if (options?.params) {
      for (const [key, value] of Object.entries(options.params)) {
        url = url.replace(` + "`{${key}}`" + `, encodeURIComponent(value));
      }
    }

    // Build query string
    if (options?.query) {
      const searchParams = new URLSearchParams();
      for (const [key, value] of Object.entries(options.query)) {
        if (value === undefined || value === null) continue;
        if (Array.isArray(value)) {
          for (const item of value) {
            searchParams.append(key, String(item));
          }
        } else {
          searchParams.set(key, String(value));
        }
      }
      const qs = searchParams.toString();
      if (qs) url += ` + "`?${qs}`" + `;
    }

    const fullUrl = config.baseUrl.replace(/\/$/, '') + url;

    // Resolve headers
    let baseHeaders: Record<string, string> = {};
    if (config.headers) {
      if (typeof config.headers === 'function') {
        baseHeaders = await config.headers();
      } else {
        baseHeaders = config.headers;
      }
    }

    const allHeaders: Record<string, string> = {
      ...baseHeaders,
      ...options?.headers,
    };

    // Build request init
    let init: RequestInit = {
      method,
      headers: allHeaders,
      signal: options?.signal,
    };

    if (options?.body !== undefined) {
      const contentType = options?.contentType ?? 'application/json';
      if (options.body instanceof FormData) {
        // Let the browser set the Content-Type with boundary
        init.body = options.body;
      } else if (contentType === 'application/json') {
        init.body = JSON.stringify(options.body);
        allHeaders['Content-Type'] = 'application/json';
        init.headers = allHeaders;
      } else {
        init.body = String(options.body);
        allHeaders['Content-Type'] = contentType;
        init.headers = allHeaders;
      }
    }

    // onRequest hook
    if (config.onRequest) {
      init = await config.onRequest(fullUrl, init);
    }

    const response = await fetcher(fullUrl, init);

    if (!response.ok) {
      let errorBody: unknown;
      try {
        errorBody = await response.json();
      } catch {
        errorBody = await response.text().catch(() => undefined);
      }
      return {
        data: null,
        error: {
          status: response.status,
          message: response.statusText,
          body: errorBody,
        },
        response,
      };
    }

    // 204 No Content
    if (response.status === 204) {
      return { data: undefined as T, error: null, response };
    }

    // Response type hint from codegen
    const respType = options?.responseType ?? 'json';

    if (respType === 'blob') {
      const data = await response.blob() as T;
      return { data, error: null, response };
    }

    if (respType === 'stream') {
      return { data: response.body as T, error: null, response };
    }

    if (respType === 'sse') {
      const conn = new SSEConnection<unknown>(response, (s: string) => JSON.parse(s));
      return { data: conn as unknown as T, error: null, response };
    }

    if (respType === 'sse-raw') {
      const conn = new SSEConnection<string>(response, (s: string) => s);
      return { data: conn as unknown as T, error: null, response };
    }

    if (respType === 'text') {
      const data = await response.text() as T;
      return { data, error: null, response };
    }

    // Default: parse based on content-type header
    const contentTypeHeader = response.headers.get('content-type') ?? '';
    if (contentTypeHeader.includes('application/json')) {
      const data = await response.json() as T;
      return { data, error: null, response };
    }

    const text = await response.text();
    return { data: text as T, error: null, response };
  };
}
`
}
