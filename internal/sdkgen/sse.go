package sdkgen

// generateSSE generates the sse.ts file with the SSEConnection class.
// Separated from client.ts for tree-shaking: only included when a controller uses SSE.
func generateSSE() string {
	return `// Auto-generated by tsgonest sdk â€” do not edit

export interface SSEEvent<T> {
  data: T;
  event?: string;
  id?: string;
  retry?: number;
}

export class SSEConnection<T> {
  private reader: ReadableStreamDefaultReader<string> | null = null;
  private buffer = '';
  private closed = false;
  private lastEventId = '';
  private listeners: Map<string, Array<(event: SSEEvent<T>) => void>> = new Map();

  constructor(
    private response: Response,
    private parse: (data: string) => T,
  ) {}

  on(event: 'message' | 'error' | string, handler: (event: SSEEvent<T>) => void): this {
    const list = this.listeners.get(event) ?? [];
    list.push(handler);
    this.listeners.set(event, list);
    return this;
  }

  close(): void {
    this.closed = true;
    this.reader?.cancel();
  }

  get lastId(): string {
    return this.lastEventId;
  }

  async *[Symbol.asyncIterator](): AsyncIterableIterator<SSEEvent<T>> {
    const body = this.response.body;
    if (!body) return;

    this.reader = body.pipeThrough(new TextDecoderStream()).getReader();

    try {
      while (!this.closed) {
        const { done, value } = await this.reader.read();
        if (done) break;
        this.buffer += value;

        const parts = this.buffer.split('\n\n');
        this.buffer = parts.pop()!;

        for (const part of parts) {
          const event = this.parseEvent(part);
          if (event) {
            yield event;
            this.emit(event);
          }
        }
      }
    } finally {
      this.reader?.cancel();
    }
  }

  private parseEvent(raw: string): SSEEvent<T> | null {
    let data = '';
    let eventName: string | undefined;
    let id: string | undefined;
    let retry: number | undefined;

    for (const line of raw.split('\n')) {
      if (line.startsWith('data:')) {
        data += (data ? '\n' : '') + line.slice(5).trimStart();
      } else if (line.startsWith('event:')) {
        eventName = line.slice(6).trimStart();
      } else if (line.startsWith('id:')) {
        id = line.slice(3).trimStart();
        this.lastEventId = id;
      } else if (line.startsWith('retry:')) {
        const val = parseInt(line.slice(6).trimStart(), 10);
        if (!isNaN(val)) retry = val;
      }
    }

    if (!data) return null;

    return {
      data: this.parse(data),
      event: eventName,
      id,
      retry,
    };
  }

  private emit(event: SSEEvent<T>): void {
    const eventType = event.event ?? 'message';
    const handlers = this.listeners.get(eventType) ?? [];
    const messageHandlers = eventType !== 'message' ? (this.listeners.get('message') ?? []) : [];
    for (const h of [...handlers, ...messageHandlers]) h(event);
  }
}
`
}
