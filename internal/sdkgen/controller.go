package sdkgen

import (
	"fmt"
	"strings"
)

// qualifiedMethodName returns a globally unique function name by prefixing
// the controller base name. e.g., ("ContactsController", "findAll") → "Contacts_findAll".
// This is used for standalone exported functions to avoid name collisions across controllers.
func qualifiedMethodName(ctrlName, methodName string) string {
	baseName := strings.TrimSuffix(ctrlName, "Controller")
	if baseName == "" {
		return methodName
	}
	return baseName + "_" + methodName
}

// generateController generates the index.ts file for a single controller.
// version is "" for unversioned, "v1" etc. for versioned (affects relative import paths).
//
// The generated file contains:
//  1. Standalone exported functions per endpoint (tree-shakeable)
//  2. An interface describing the controller shape
//  3. A factory function that returns an object delegating to the standalone functions
func generateController(ctrl ControllerGroup, doc *SDKDocument, version string) string {
	var sb strings.Builder
	sb.WriteString("// Auto-generated by tsgonest sdk — do not edit\n\n")

	// Compute relative prefix: "../" for unversioned, "../../" for versioned
	relPrefix := "../"
	if version != "" {
		relPrefix = "../../"
	}

	// Collect type imports from the shared types.ts
	typeImports := collectTypeImports(ctrl, doc.Schemas)

	if len(typeImports) > 0 {
		sb.WriteString("import type { ")
		sb.WriteString(strings.Join(typeImports, ", "))
		sb.WriteString(" } from '")
		sb.WriteString(relPrefix + "types")
		sb.WriteString("';\n")
	}

	hasFormData := hasFormDataBody(ctrl)
	hasSSE := hasSSEResponse(ctrl)

	// Value imports (buildFormData from form-data.ts, SSEConnection from sse.ts)
	if hasFormData {
		sb.WriteString("import { buildFormData } from '")
		sb.WriteString(relPrefix + "form-data")
		sb.WriteString("';\n")
	}
	if hasSSE {
		sb.WriteString("import { SSEConnection } from '")
		sb.WriteString(relPrefix + "sse")
		sb.WriteString("';\n")
	}

	// Type imports from client.ts
	sb.WriteString("import type { RequestFn, SDKResult } from '")
	sb.WriteString(relPrefix + "client")
	sb.WriteString("';\n")
	sb.WriteString("\n")

	// ── Standalone exported functions (tree-shakeable) ──────────────────

	for _, method := range ctrl.Methods {
		sb.WriteString(generateStandaloneFunction(ctrl.Name, method))
		sb.WriteString("\n")
	}

	// ── Options types ──────────────────────────────────────────────────

	for _, method := range ctrl.Methods {
		optTypeName := methodOptionsTypeName(method.Name)
		optType := buildOptionsTypeDecl(method, optTypeName)
		if optType != "" {
			sb.WriteString(optType)
			sb.WriteString("\n")
		}
	}

	// ── Interface ──────────────────────────────────────────────────────

	ifaceName := controllerInterfaceName(ctrl.Name)
	sb.WriteString(fmt.Sprintf("export interface %s {\n", ifaceName))
	for _, method := range ctrl.Methods {
		jsdoc := buildMethodJSDoc(method)
		if jsdoc != "" {
			sb.WriteString(jsdoc)
		}
		optionsType := buildOptionsType(method)
		responseType := buildResponseType(method)
		if optionsType == "" {
			sb.WriteString(fmt.Sprintf("  %s(options?: { signal?: AbortSignal; headers?: Record<string, string>; responseType?: 'json' | 'blob' | 'text' | 'stream'; contentType?: string }): Promise<SDKResult<%s>>;\n", method.Name, responseType))
		} else {
			sb.WriteString(fmt.Sprintf("  %s(options: %s): Promise<SDKResult<%s>>;\n", method.Name, optionsType, responseType))
		}
	}
	sb.WriteString("}\n\n")

	// ── Factory function (delegates to standalone functions) ────────────

	factoryName := controllerFactoryName(ctrl.Name)
	sb.WriteString(fmt.Sprintf("export function %s(request: RequestFn): %s {\n", factoryName, ifaceName))
	sb.WriteString("  return {\n")
	for _, method := range ctrl.Methods {
		qName := qualifiedMethodName(ctrl.Name, method.Name)
		optionsType := buildOptionsType(method)
		if optionsType == "" {
			sb.WriteString(fmt.Sprintf("    %s: (options?) => %s(request, options),\n", method.Name, qName))
		} else {
			sb.WriteString(fmt.Sprintf("    %s: (options) => %s(request, options),\n", method.Name, qName))
		}
	}
	sb.WriteString("  };\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateStandaloneFunction generates a single top-level exported async function for an endpoint.
// These are independently importable and tree-shakeable.
// ctrlName is used to create a qualified function name (e.g., "Contacts_findAll") to avoid collisions.
func generateStandaloneFunction(ctrlName string, method SDKMethod) string {
	var sb strings.Builder
	qName := qualifiedMethodName(ctrlName, method.Name)

	// JSDoc
	jsdoc := buildMethodJSDoc(method)
	if jsdoc != "" {
		// Standalone functions use no indentation for JSDoc
		jsdoc = strings.ReplaceAll(jsdoc, "  /**", "/**")
		jsdoc = strings.ReplaceAll(jsdoc, "   *", " *")
		sb.WriteString(jsdoc)
	}

	// Function signature
	optionsType := buildOptionsType(method)
	responseType := buildResponseType(method)
	if optionsType == "" {
		sb.WriteString(fmt.Sprintf("export async function %s(\n  request: RequestFn,\n  options?: { signal?: AbortSignal; headers?: Record<string, string>; responseType?: 'json' | 'blob' | 'text' | 'stream'; contentType?: string },\n): Promise<SDKResult<%s>> {\n", qName, responseType))
	} else {
		sb.WriteString(fmt.Sprintf("export async function %s(\n  request: RequestFn,\n  options: %s,\n): Promise<SDKResult<%s>> {\n", qName, optionsType, responseType))
	}

	// Build params object for path interpolation
	if len(method.PathParams) > 0 {
		sb.WriteString("  const params: Record<string, string> = {\n")
		for _, p := range method.PathParams {
			sb.WriteString(fmt.Sprintf("    %s: String(%s),\n", tsPropertyKey(p.Name), tsPropAccess("options", p.Name)))
		}
		sb.WriteString("  };\n")
	}

	// Build query object
	if len(method.QueryParams) > 0 {
		sb.WriteString("  const query: Record<string, unknown> = {};\n")
		for _, p := range method.QueryParams {
			sb.WriteString(fmt.Sprintf("  if (%s !== undefined) query[\"%s\"] = %s;\n", tsOptionalAccess("options.query", p.Name), escapeJSString(p.Name), tsPropAccess("options.query", p.Name)))
		}
	}

	// Handle multipart/form-data: wrap body in FormData
	if method.Body != nil && method.Body.ContentType == "multipart/form-data" {
		sb.WriteString("  const formData = buildFormData(options.body);\n")
	}

	// Determine if this is an SSE endpoint
	isSSE := method.ResponseContentType == "text/event-stream"

	if isSSE {
		// SSE endpoints: call request, then wrap the raw response in SSEConnection
		sb.WriteString(fmt.Sprintf("  const result = await request<Response>('%s', '%s', {\n", method.HTTPMethod, method.Path))
		writeRequestOptions(&sb, method, "  ")
		sb.WriteString("  });\n")
		sb.WriteString("  if (result.error) return result as any;\n")

		if method.SSEEventType != "" {
			sb.WriteString(fmt.Sprintf("  const conn = new SSEConnection<%s>(result.response, (s: string) => JSON.parse(s));\n", method.SSEEventType))
		} else {
			sb.WriteString("  const conn = new SSEConnection<string>(result.response, (s: string) => s);\n")
		}
		sb.WriteString("  return { data: conn as any, error: null, response: result.response };\n")
	} else {
		// Normal endpoints: delegate to request directly
		sb.WriteString(fmt.Sprintf("  return request('%s', '%s', {\n", method.HTTPMethod, method.Path))
		writeRequestOptions(&sb, method, "  ")
		sb.WriteString("  });\n")
	}

	sb.WriteString("}\n")

	return sb.String()
}

// writeRequestOptions writes the options object properties for a request() call.
func writeRequestOptions(sb *strings.Builder, method SDKMethod, indent string) {
	if len(method.PathParams) > 0 {
		sb.WriteString(indent + "  params,\n")
	}
	if len(method.QueryParams) > 0 {
		sb.WriteString(indent + "  query,\n")
	}
	if method.Body != nil {
		if method.Body.ContentType == "multipart/form-data" {
			sb.WriteString(indent + "  body: formData,\n")
			sb.WriteString(indent + "  contentType: 'multipart/form-data',\n")
		} else {
			sb.WriteString(indent + "  body: options.body,\n")
			if method.Body.ContentType != "" && method.Body.ContentType != "application/json" {
				sb.WriteString(fmt.Sprintf(indent+"  contentType: '%s',\n", method.Body.ContentType))
			}
		}
	}
	if method.ResponseContentType != "" && method.ResponseContentType != "application/json" {
		hint := responseTypeHint(method.ResponseContentType)
		if hint == "sse" && method.SSEEventType == "" {
			hint = "sse-raw"
		}
		sb.WriteString(fmt.Sprintf(indent+"  responseType: '%s',\n", hint))
	}
	sb.WriteString(indent + "  signal: options?.signal,\n")
	sb.WriteString(indent + "  headers: options?.headers,\n")
	sb.WriteString(indent + "  ...(options?.responseType && { responseType: options.responseType }),\n")
	sb.WriteString(indent + "  ...(options?.contentType && { contentType: options.contentType }),\n")
}

// buildOptionsType returns the inline type for the options parameter.
// Returns empty string if no options are needed (method takes no params/body).
func buildOptionsType(method SDKMethod) string {
	parts := buildOptionsParts(method)
	if len(parts) == 0 {
		return ""
	}
	return methodOptionsTypeName(method.Name)
}

func buildOptionsTypeDecl(method SDKMethod, typeName string) string {
	parts := buildOptionsParts(method)
	if len(parts) == 0 {
		return ""
	}

	var sb strings.Builder
	sb.WriteString(fmt.Sprintf("export interface %s {\n", typeName))

	// Path params (required)
	for _, p := range method.PathParams {
		sb.WriteString(fmt.Sprintf("  %s: %s;\n", tsPropertyKey(p.Name), p.TSType))
	}

	// Query params
	if len(method.QueryParams) > 0 {
		hasRequired := false
		for _, p := range method.QueryParams {
			if p.Required {
				hasRequired = true
				break
			}
		}
		opt := "?"
		if hasRequired {
			opt = ""
		}
		sb.WriteString(fmt.Sprintf("  query%s: {\n", opt))
		for _, p := range method.QueryParams {
			qopt := "?"
			if p.Required {
				qopt = ""
			}
			sb.WriteString(fmt.Sprintf("    %s%s: %s;\n", tsPropertyKey(p.Name), qopt, p.TSType))
		}
		sb.WriteString("  };\n")
	}

	// Body
	if method.Body != nil {
		opt := "?"
		if method.Body.Required {
			opt = ""
		}
		sb.WriteString(fmt.Sprintf("  body%s: %s;\n", opt, method.Body.TSType))
	}

	// Always include optional signal, headers, and override fields
	sb.WriteString("  signal?: AbortSignal;\n")
	sb.WriteString("  headers?: Record<string, string>;\n")
	sb.WriteString("  /** Override the response type handling */\n")
	sb.WriteString("  responseType?: 'json' | 'blob' | 'text' | 'stream';\n")
	sb.WriteString("  /** Override the request content type */\n")
	sb.WriteString("  contentType?: string;\n")
	sb.WriteString("}\n")

	return sb.String()
}

func buildOptionsParts(method SDKMethod) []string {
	var parts []string
	if len(method.PathParams) > 0 {
		parts = append(parts, "path")
	}
	if len(method.QueryParams) > 0 {
		parts = append(parts, "query")
	}
	if method.Body != nil {
		parts = append(parts, "body")
	}
	return parts
}

func hasRequiredOptions(method SDKMethod) bool {
	if len(method.PathParams) > 0 {
		return true
	}
	if method.Body != nil && method.Body.Required {
		return true
	}
	for _, p := range method.QueryParams {
		if p.Required {
			return true
		}
	}
	return false
}

func buildResponseType(method SDKMethod) string {
	if method.IsVoid {
		return "void"
	}
	if method.ResponseContentType == "text/event-stream" {
		if method.SSEEventType != "" {
			return "SSEConnection<" + method.SSEEventType + ">"
		}
		return "SSEConnection<string>"
	}
	return method.ResponseType
}

// collectTypeImports returns sorted, deduplicated type names referenced by the controller.
func collectTypeImports(ctrl ControllerGroup, schemas map[string]*SchemaNode) []string {
	refs := make(map[string]bool)
	for _, method := range ctrl.Methods {
		collectRefs(method.ResponseType, schemas, refs)
		for _, p := range method.PathParams {
			collectRefs(p.TSType, schemas, refs)
		}
		for _, p := range method.QueryParams {
			collectRefs(p.TSType, schemas, refs)
		}
		if method.Body != nil {
			collectRefs(method.Body.TSType, schemas, refs)
		}
		if method.SSEEventType != "" {
			collectRefs(method.SSEEventType, schemas, refs)
		}
	}

	var result []string
	for ref := range refs {
		result = append(result, ref)
	}
	if len(result) == 0 {
		return nil
	}
	sortStrings(result)
	return result
}

func collectRefs(tsType string, schemas map[string]*SchemaNode, refs map[string]bool) {
	// Simple heuristic: if the type name matches a schema name, it's a reference
	for name := range schemas {
		if strings.Contains(tsType, name) {
			refs[name] = true
		}
	}
}

func sortStrings(s []string) {
	for i := 1; i < len(s); i++ {
		for j := i; j > 0 && s[j-1] > s[j]; j-- {
			s[j-1], s[j] = s[j], s[j-1]
		}
	}
}

// buildMethodJSDoc generates a JSDoc comment block for an SDK method.
func buildMethodJSDoc(method SDKMethod) string {
	var lines []string

	if method.Summary != "" {
		lines = append(lines, method.Summary)
	}
	if method.Description != "" && method.Description != method.Summary {
		if len(lines) > 0 {
			lines = append(lines, "")
		}
		// Split description into lines for multi-line JSDoc
		for _, line := range strings.Split(method.Description, "\n") {
			lines = append(lines, line)
		}
	}
	if method.Deprecated {
		lines = append(lines, "@deprecated")
	}

	if len(lines) == 0 {
		return ""
	}

	// Single line
	if len(lines) == 1 {
		return fmt.Sprintf("  /** %s */\n", lines[0])
	}

	// Multi-line
	var sb strings.Builder
	sb.WriteString("  /**\n")
	for _, line := range lines {
		if line == "" {
			sb.WriteString("   *\n")
		} else {
			sb.WriteString(fmt.Sprintf("   * %s\n", line))
		}
	}
	sb.WriteString("   */\n")
	return sb.String()
}

// responseTypeHint maps content types to response type hints for the request function.
func responseTypeHint(contentType string) string {
	switch {
	case contentType == "text/event-stream":
		return "sse"
	case contentType == "text/plain" || contentType == "text/html" || contentType == "text/csv":
		return "text"
	case strings.HasPrefix(contentType, "application/octet-stream"),
		strings.HasPrefix(contentType, "application/pdf"),
		strings.HasPrefix(contentType, "image/"),
		strings.HasPrefix(contentType, "audio/"),
		strings.HasPrefix(contentType, "video/"):
		return "blob"
	default:
		return "json"
	}
}

// hasSSEResponse returns true if any method has a text/event-stream response.
func hasSSEResponse(ctrl ControllerGroup) bool {
	for _, m := range ctrl.Methods {
		if m.ResponseContentType == "text/event-stream" {
			return true
		}
	}
	return false
}

// hasFormDataBody returns true if any method uses multipart/form-data.
func hasFormDataBody(ctrl ControllerGroup) bool {
	for _, m := range ctrl.Methods {
		if m.Body != nil && m.Body.ContentType == "multipart/form-data" {
			return true
		}
	}
	return false
}

// controllerInterfaceName returns the interface name for a controller.
// e.g., "OrdersController" → "OrdersController"
func controllerInterfaceName(name string) string {
	if !strings.HasSuffix(name, "Controller") {
		return name + "Controller"
	}
	return name
}

// controllerFactoryName returns the factory function name.
// e.g., "OrdersController" → "createOrdersController"
func controllerFactoryName(name string) string {
	base := strings.TrimSuffix(name, "Controller")
	if base == "" {
		base = "Default"
	}
	return "create" + base + "Controller"
}

func methodOptionsTypeName(methodName string) string {
	return capitalize(methodName) + "Options"
}
