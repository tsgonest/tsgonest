package codegen

import (
	"fmt"
	"sort"
	"strings"

	"github.com/tsgonest/tsgonest/internal/metadata"
)

// GenerateCompanion generates a consolidated companion file (.tsgonest.js) containing
// validation, assertion, serialization, and Standard Schema functions for a named type.
// This replaces the old separate validate.js + serialize.js files.
func GenerateCompanion(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry) string {
	return GenerateCompanionSelective(typeName, meta, registry, true, true)
}

// GenerateCompanionSelective generates a companion file with optional sections.
// includeValidation controls validate/assert/schema functions.
// includeSerialization controls the serialize function.
func GenerateCompanionSelective(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, includeValidation bool, includeSerialization bool) string {
	e := NewEmitter()
	e.Line("// Auto-generated by tsgonest — do not edit")
	e.Blank()

	if includeValidation {
		// Collect and emit imports for custom validator functions (Validate<typeof fn>)
		imports := collectValidateImports(meta, registry)
		for _, imp := range imports {
			e.Line("import { %s } from %q;", imp.FnName, imp.Module)
		}
		if len(imports) > 0 {
			e.Blank()
		}
	}

	if includeSerialization {
		// Serialization helper — must be before any serialize function that uses it
		e.Block("function __jsonStr(s)")
		e.Line("return JSON.stringify(s);")
		e.EndBlock()
		e.Blank()
	}

	if includeValidation {
		// Generate validate function
		ctx := &validateCtx{
			generating: map[string]bool{typeName: true},
		}
		generateValidateFunction(e, typeName, meta, registry, ctx)
		e.Blank()

		// Generate assert function
		generateAssertFunction(e, typeName)
		e.Blank()
	}

	if includeSerialization {
		// Generate serialize function
		sCtx := &serializeCtx{
			generating: map[string]bool{typeName: true},
		}
		generateSerializeFunction(e, typeName, meta, registry, sCtx)
		e.Blank()
	}

	if includeValidation {
		// Generate Standard Schema v1 wrapper
		generateStandardSchemaWrapper(e, typeName)
	}

	return e.String()
}

// GenerateCompanionTypes generates TypeScript declaration (.tsgonest.d.ts) content
// for the consolidated companion file, including Standard Schema v1 type info.
func GenerateCompanionTypes(typeName string) string {
	return GenerateCompanionTypesSelective(typeName, true, true)
}

// GenerateCompanionTypesSelective generates type declarations with optional sections.
func GenerateCompanionTypesSelective(typeName string, includeValidation bool, includeSerialization bool) string {
	e := NewEmitter()
	e.Line("// Auto-generated by tsgonest — do not edit")
	e.Blank()

	if includeValidation {
		// Define the StandardSchemaV1Props interface inline
		e.Line("interface StandardSchemaV1Props {")
		e.Line("  readonly version: 1;")
		e.Line("  readonly vendor: string;")
		e.Line("  readonly validate: (value: unknown) => { value: any } | { issues: Array<{ message: string; path?: Array<{ key: string }> }> };")
		e.Line("}")
		e.Blank()

		validateResult := fmt.Sprintf("{ success: true; data: %s } | { success: false; errors: Array<{ path: string; message: string }> }", typeName)
		e.Line("export declare function validate%s(input: unknown): %s;", typeName, validateResult)
		e.Line("export declare function assert%s(input: unknown): %s;", typeName, typeName)
	}

	if includeSerialization {
		e.Line("export declare function serialize%s(input: %s): string;", typeName, typeName)
	}

	if includeValidation {
		e.Line("export declare const schema%s: { readonly \"~standard\": StandardSchemaV1Props };", typeName)
	}

	return e.String()
}

// validateImport represents an import needed for a custom validator function.
type validateImport struct {
	FnName string
	Module string
}

// collectValidateImports scans the metadata tree for Validate<typeof fn> constraints
// and returns unique import entries.
func collectValidateImports(meta *metadata.Metadata, registry *metadata.TypeRegistry) []validateImport {
	seen := make(map[string]bool)
	visitedRefs := make(map[string]bool) // prevent infinite recursion on recursive types
	var imports []validateImport

	var scan func(m *metadata.Metadata)
	scan = func(m *metadata.Metadata) {
		if m == nil {
			return
		}

		switch m.Kind {
		case metadata.KindObject:
			for i := range m.Properties {
				prop := &m.Properties[i]
				if prop.Constraints != nil && prop.Constraints.ValidateFn != nil && prop.Constraints.ValidateModule != nil {
					key := *prop.Constraints.ValidateFn + "|" + *prop.Constraints.ValidateModule
					if !seen[key] {
						seen[key] = true
						imports = append(imports, validateImport{
							FnName: *prop.Constraints.ValidateFn,
							Module: toRelativeImportPath(*prop.Constraints.ValidateModule),
						})
					}
				}
				scan(&prop.Type)
			}
		case metadata.KindArray:
			if m.ElementType != nil {
				scan(m.ElementType)
			}
		case metadata.KindTuple:
			for i := range m.Elements {
				scan(&m.Elements[i].Type)
			}
		case metadata.KindUnion:
			for i := range m.UnionMembers {
				scan(&m.UnionMembers[i])
			}
		case metadata.KindRef:
			if m.Ref != "" && registry != nil && !visitedRefs[m.Ref] {
				visitedRefs[m.Ref] = true
				if resolved, ok := registry.Types[m.Ref]; ok {
					scan(resolved)
				}
			}
		}
	}

	scan(meta)

	// Sort by function name for deterministic output
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].FnName < imports[j].FnName
	})

	return imports
}

// toRelativeImportPath converts a TypeScript source file path to a relative import path.
// Strips the .ts/.tsx extension and ensures it starts with "./" or "../".
func toRelativeImportPath(filePath string) string {
	// Strip .ts/.tsx/.mts/.cts extension
	for _, ext := range []string{".ts", ".tsx", ".mts", ".cts"} {
		if len(filePath) > len(ext) && filePath[len(filePath)-len(ext):] == ext {
			filePath = filePath[:len(filePath)-len(ext)]
			break
		}
	}
	// Ensure relative path prefix
	if !strings.HasPrefix(filePath, ".") && !strings.HasPrefix(filePath, "/") {
		filePath = "./" + filePath
	}
	return filePath
}

// validateCtx tracks codegen state to prevent infinite recursion on recursive types.
type validateCtx struct {
	// generating tracks type names currently being generated to detect recursion.
	generating map[string]bool
}

// generateValidateFunction generates: export function validate<Name>(input) { ... }
func generateValidateFunction(e *Emitter, typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, ctx *validateCtx) {
	fnName := "validate" + typeName
	e.Block("export function %s(input)", fnName)
	e.Line("const errors = [];")

	generateTypeCheck(e, "input", "", meta, registry, 0, ctx)

	e.Block("if (errors.length > 0)")
	e.Line("return { success: false, errors };")
	e.EndBlock()
	e.Line("return { success: true, data: input };")
	e.EndBlock()
}

// generateAssertFunction generates: export function assert<Name>(input) { ... }
func generateAssertFunction(e *Emitter, typeName string) {
	fnName := "assert" + typeName
	validateFn := "validate" + typeName
	e.Block("export function %s(input)", fnName)
	e.Line("const result = %s(input);", validateFn)
	e.Block("if (!result.success)")
	e.Line("const err = new Error(\"Validation failed for %s\");", typeName)
	e.Line("err.errors = result.errors;")
	e.Line("throw err;")
	e.EndBlock()
	e.Line("return result.data;")
	e.EndBlock()
}

// generateTypeCheck generates validation checks for a type at the given access path.
// `accessor` is the JS expression to access the value (e.g., "input", "input.name").
// `path` is the error path string (e.g., "input.name").
func generateTypeCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	if path == "" {
		path = accessor
	}

	// Handle nullable
	if meta.Nullable && meta.Optional {
		e.Block("if (%s !== null && %s !== undefined)", accessor, accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Nullable {
		e.Block("if (%s !== null)", accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Optional {
		e.Block("if (%s !== undefined)", accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}

	generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
}

// generateTypeCheckInner generates the actual type checks (after null/undefined handling).
func generateTypeCheckInner(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	switch meta.Kind {
	case metadata.KindAtomic:
		generateAtomicCheck(e, accessor, path, meta.Atomic)
		// Template literal types produce a regex pattern — validate it at runtime
		if meta.Atomic == "string" && meta.TemplatePattern != "" {
			e.Block("if (typeof %s === \"string\" && !/%s/.test(%s))", accessor, meta.TemplatePattern, accessor)
			e.Line("errors.push({ path: %q, expected: \"pattern %s\", received: %s });", path, jsStringEscape(meta.TemplatePattern), accessor)
			e.EndBlock()
		}

	case metadata.KindLiteral:
		generateLiteralCheck(e, accessor, path, meta.LiteralValue)

	case metadata.KindObject:
		generateObjectCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindArray:
		generateArrayCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindTuple:
		generateTupleCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindUnion:
		generateUnionCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindRef:
		// For recursive references (type currently being generated),
		// emit a recursive function call instead of inlining to prevent
		// infinite recursion during codegen.
		if ctx != nil && ctx.generating[meta.Ref] {
			// Emit a recursive call to the validate function being generated
			fnName := "validate" + meta.Ref
			e.Line("{ const _r = %s(%s); if (!_r.success) errors.push(..._r.errors.map(e => ({ ...e, path: e.path.replace(/^input/, %q) }))); }", fnName, accessor, path)
		} else if resolved, ok := registry.Types[meta.Ref]; ok {
			// Non-recursive ref: inline the checks as before
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			generateTypeCheck(e, accessor, path, resolved, registry, depth, ctx)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
		}

	case metadata.KindEnum:
		// Enum types are handled as unions of their literal values
		if len(meta.EnumValues) > 0 {
			generateEnumCheck(e, accessor, path, meta)
		}

	case metadata.KindNative:
		generateNativeCheck(e, accessor, path, meta)

	case metadata.KindAny, metadata.KindUnknown:
		// No validation for any/unknown

	case metadata.KindNever:
		e.Line("errors.push({ path: %q, expected: \"never\", received: typeof %s });", path, accessor)

	case metadata.KindVoid:
		e.Block("if (%s !== undefined)", accessor)
		e.Line("errors.push({ path: %q, expected: \"void\", received: typeof %s });", path, accessor)
		e.EndBlock()
	}
}

func generateAtomicCheck(e *Emitter, accessor string, path string, atomic string) {
	switch atomic {
	case "string":
		e.Block("if (typeof %s !== \"string\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"string\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "number":
		e.Block("if (typeof %s !== \"number\" || !Number.isFinite(%s))", accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"number\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "boolean":
		e.Block("if (typeof %s !== \"boolean\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"boolean\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "bigint":
		e.Block("if (typeof %s !== \"bigint\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"bigint\", received: typeof %s });", path, accessor)
		e.EndBlock()
	}
}

func generateLiteralCheck(e *Emitter, accessor string, path string, value any) {
	switch v := value.(type) {
	case string:
		e.Block("if (%s !== %q)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %q, received: %s });", path, v, accessor)
		e.EndBlock()
	case float64:
		e.Block("if (%s !== %v)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %v, received: %s });", path, v, accessor)
		e.EndBlock()
	case bool:
		e.Block("if (%s !== %v)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %v, received: %s });", path, v, accessor)
		e.EndBlock()
	}
}

func generateObjectCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// Check it's an object
	e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
	e.Line("errors.push({ path: %q, expected: \"object\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Handle object strictness
	if meta.Strictness == "strict" || meta.Strictness == "strip" {
		// Build known keys set
		knownKeys := make([]string, 0, len(meta.Properties))
		for _, prop := range meta.Properties {
			knownKeys = append(knownKeys, prop.Name)
		}
		knownSetExpr := "new Set([" + joinQuoted(knownKeys) + "])"

		if meta.Strictness == "strict" {
			// Strict: reject unknown properties
			kVar := fmt.Sprintf("_k%d", depth)
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
			e.Line("errors.push({ path: %q + \".\" + %s, expected: \"known property\", received: %s });", path, kVar, kVar)
			e.EndBlock()
			e.EndBlock()
		} else if meta.Strictness == "strip" {
			// Strip: remove unknown properties
			kVar := fmt.Sprintf("_k%d", depth)
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
			e.Line("delete %s[%s];", accessor, kVar)
			e.EndBlock()
			e.EndBlock()
		}
	}

	// Check each property
	for _, prop := range meta.Properties {
		propAccessor := accessor + "." + prop.Name
		propPath := path + "." + prop.Name

		// Emit default value assignment BEFORE validation.
		// When a property has @default and the value is undefined, fill it in.
		if prop.Constraints != nil && prop.Constraints.Default != nil {
			jsDefault := defaultToJSLiteral(*prop.Constraints.Default, &prop.Type)
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("%s = %s;", propAccessor, jsDefault)
			e.EndBlock()
		}

		if prop.Required && !prop.Type.Optional {
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("errors.push({ path: %q, expected: \"%s\", received: \"undefined\" });", propPath, describeType(&prop.Type))
			e.EndBlockSuffix(" else {")
			e.indent++
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			// After type check, emit constraint checks
			if prop.Constraints != nil {
				generateConstraintChecks(e, propAccessor, propPath, &prop)
			}
			e.indent--
			e.Line("}")
		} else {
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			// After type check, emit constraint checks (only if value is present)
			if prop.Constraints != nil {
				if prop.Type.Optional || !prop.Required {
					e.Block("if (%s !== undefined)", propAccessor)
					generateConstraintChecks(e, propAccessor, propPath, &prop)
					e.EndBlock()
				} else {
					generateConstraintChecks(e, propAccessor, propPath, &prop)
				}
			}
		}
	}

	// Index signature validation: for objects with [key: string]: T,
	// validate that all keys not in the declared properties have values matching T.
	if meta.IndexSignature != nil {
		kVar := fmt.Sprintf("_ik%d", depth)
		// Build set of known property names to exclude
		if len(meta.Properties) > 0 {
			knownKeys := make([]string, 0, len(meta.Properties))
			for _, prop := range meta.Properties {
				knownKeys = append(knownKeys, prop.Name)
			}
			knownSetExpr := "new Set([" + joinQuoted(knownKeys) + "])"
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
		} else {
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
		}

		elemAccessor := fmt.Sprintf("%s[%s]", accessor, kVar)
		elemPath := fmt.Sprintf("%s[\" + %s + \"]", path, kVar)
		generateTypeCheck(e, elemAccessor, elemPath, &meta.IndexSignature.ValueType, registry, depth+1, ctx)

		if len(meta.Properties) > 0 {
			e.EndBlock() // close the if (!knownSet.has) block
		}
		e.EndBlock() // close the for loop
	}

	e.indent--
	e.Line("}")
}

// generateTransforms emits JS statements that transform the value in-place before validation.
func generateTransforms(e *Emitter, accessor string, transforms []string) {
	for _, t := range transforms {
		switch t {
		case "trim":
			e.Block("if (typeof %s === \"string\")", accessor)
			e.Line("%s = %s.trim();", accessor, accessor)
			e.EndBlock()
		case "toLowerCase":
			e.Block("if (typeof %s === \"string\")", accessor)
			e.Line("%s = %s.toLowerCase();", accessor, accessor)
			e.EndBlock()
		case "toUpperCase":
			e.Block("if (typeof %s === \"string\")", accessor)
			e.Line("%s = %s.toUpperCase();", accessor, accessor)
			e.EndBlock()
		}
	}
}

// generateCoercion emits JS code to coerce string inputs to the declared type.
// This runs before type checks so "123" becomes 123 before the typeof check.
func generateCoercion(e *Emitter, accessor string, typeMeta *metadata.Metadata) {
	if typeMeta.Kind != metadata.KindAtomic {
		return
	}
	switch typeMeta.Atomic {
	case "number":
		// string → number via unary +
		e.Block("if (typeof %s === \"string\")", accessor)
		e.Line("const _n = +%s;", accessor)
		e.Block("if (!Number.isNaN(_n))")
		e.Line("%s = _n;", accessor)
		e.EndBlock()
		e.EndBlock()
	case "boolean":
		// "true"/"false" → boolean
		e.Block("if (%s === \"true\")", accessor)
		e.Line("%s = true;", accessor)
		e.EndBlockSuffix(fmt.Sprintf(" else if (%s === \"false\") {", accessor))
		e.indent++
		e.Line("%s = false;", accessor)
		e.EndBlock()
	}
	// Date coercion is handled at the type check level (KindNative "Date"),
	// not at the constraint level, so it's omitted here.
}

// generateConstraintChecks emits JS validation checks for JSDoc constraints.
func generateConstraintChecks(e *Emitter, accessor string, path string, prop *metadata.Property) {
	c := prop.Constraints
	if c == nil {
		return
	}

	// Emit transforms BEFORE validation checks
	if len(c.Transforms) > 0 {
		generateTransforms(e, accessor, c.Transforms)
	}

	// Emit coercion BEFORE type checks
	if c.Coerce != nil && *c.Coerce {
		generateCoercion(e, accessor, &prop.Type)
	}

	// Helper: use per-constraint error if present, then global ErrorMessage, then default.
	// constraintKey is the Constraints field name (e.g., "format", "minLength", "minimum").
	errMsg := func(constraintKey string, defaultExpected string) string {
		if c.Errors != nil {
			if msg, ok := c.Errors[constraintKey]; ok {
				return jsStringEscape(msg)
			}
		}
		if c.ErrorMessage != nil {
			return jsStringEscape(*c.ErrorMessage)
		}
		return defaultExpected
	}

	// Numeric constraints
	if c.Minimum != nil {
		e.Block("if (typeof %s === \"number\" && %s < %v)", accessor, accessor, *c.Minimum)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("minimum", fmt.Sprintf("minimum %v", *c.Minimum)), accessor)
		e.EndBlock()
	}
	if c.Maximum != nil {
		e.Block("if (typeof %s === \"number\" && %s > %v)", accessor, accessor, *c.Maximum)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("maximum", fmt.Sprintf("maximum %v", *c.Maximum)), accessor)
		e.EndBlock()
	}
	if c.ExclusiveMinimum != nil {
		e.Block("if (typeof %s === \"number\" && %s <= %v)", accessor, accessor, *c.ExclusiveMinimum)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("exclusiveMinimum", fmt.Sprintf("exclusiveMinimum %v", *c.ExclusiveMinimum)), accessor)
		e.EndBlock()
	}
	if c.ExclusiveMaximum != nil {
		e.Block("if (typeof %s === \"number\" && %s >= %v)", accessor, accessor, *c.ExclusiveMaximum)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("exclusiveMaximum", fmt.Sprintf("exclusiveMaximum %v", *c.ExclusiveMaximum)), accessor)
		e.EndBlock()
	}
	if c.MultipleOf != nil {
		e.Block("if (typeof %s === \"number\" && %s %% %v !== 0)", accessor, accessor, *c.MultipleOf)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("multipleOf", fmt.Sprintf("multipleOf %v", *c.MultipleOf)), accessor)
		e.EndBlock()
	}
	if c.NumericType != nil {
		generateNumericTypeCheck(e, accessor, path, *c.NumericType, c.ErrorMessage, c.Errors)
	}

	// String length constraints
	if c.MinLength != nil {
		e.Block("if (typeof %s === \"string\" && %s.length < %d)", accessor, accessor, *c.MinLength)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("minLength", fmt.Sprintf("minLength %d", *c.MinLength)), accessor)
		e.EndBlock()
	}
	if c.MaxLength != nil {
		e.Block("if (typeof %s === \"string\" && %s.length > %d)", accessor, accessor, *c.MaxLength)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("maxLength", fmt.Sprintf("maxLength %d", *c.MaxLength)), accessor)
		e.EndBlock()
	}

	// Pattern constraint
	if c.Pattern != nil {
		e.Block("if (typeof %s === \"string\" && !/%s/.test(%s))", accessor, *c.Pattern, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("pattern", fmt.Sprintf("pattern %s", *c.Pattern)), accessor)
		e.EndBlock()
	}

	// Format constraint
	if c.Format != nil {
		generateFormatCheck(e, accessor, path, *c.Format, c.ErrorMessage, c.Errors)
	}

	// Array constraints
	if c.MinItems != nil {
		e.Block("if (Array.isArray(%s) && %s.length < %d)", accessor, accessor, *c.MinItems)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("minItems", fmt.Sprintf("minItems %d", *c.MinItems)), accessor)
		e.EndBlock()
	}
	if c.MaxItems != nil {
		e.Block("if (Array.isArray(%s) && %s.length > %d)", accessor, accessor, *c.MaxItems)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("maxItems", fmt.Sprintf("maxItems %d", *c.MaxItems)), accessor)
		e.EndBlock()
	}
	if c.UniqueItems != nil && *c.UniqueItems {
		e.Block("if (Array.isArray(%s) && new Set(%s).size !== %s.length)", accessor, accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"duplicate items\" });", path, errMsg("uniqueItems", "uniqueItems"))
		e.EndBlock()
	}

	// String content checks (Zod parity)
	if c.StartsWith != nil {
		escaped := jsStringEscape(*c.StartsWith)
		e.Block("if (typeof %s === \"string\" && !%s.startsWith(\"%s\"))", accessor, accessor, escaped)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("startsWith", fmt.Sprintf("startsWith %s", escaped)), accessor)
		e.EndBlock()
	}
	if c.EndsWith != nil {
		escaped := jsStringEscape(*c.EndsWith)
		e.Block("if (typeof %s === \"string\" && !%s.endsWith(\"%s\"))", accessor, accessor, escaped)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("endsWith", fmt.Sprintf("endsWith %s", escaped)), accessor)
		e.EndBlock()
	}
	if c.Includes != nil {
		escaped := jsStringEscape(*c.Includes)
		e.Block("if (typeof %s === \"string\" && !%s.includes(\"%s\"))", accessor, accessor, escaped)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("includes", fmt.Sprintf("includes %s", escaped)), accessor)
		e.EndBlock()
	}
	if c.Uppercase != nil && *c.Uppercase {
		e.Block("if (typeof %s === \"string\" && %s !== %s.toUpperCase())", accessor, accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("uppercase", "uppercase"), accessor)
		e.EndBlock()
	}
	if c.Lowercase != nil && *c.Lowercase {
		e.Block("if (typeof %s === \"string\" && %s !== %s.toLowerCase())", accessor, accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("lowercase", "lowercase"), accessor)
		e.EndBlock()
	}

	// Custom validator function: Validate<typeof fn>
	if c.ValidateFn != nil {
		fnName := *c.ValidateFn
		e.Block("if (!%s(%s))", fnName, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("validate", fmt.Sprintf("validate(%s)", fnName)), accessor)
		e.EndBlock()
	}
}

// generateNumericTypeCheck emits validation for @type int32/uint32/int64/uint64/float/double.
// Checks perConstraintErrors["type"] first, then customError (global), then default.
func generateNumericTypeCheck(e *Emitter, accessor string, path string, numType string, customError *string, perConstraintErrors map[string]string) {
	errMsg := func(defaultExpected string) string {
		if perConstraintErrors != nil {
			if msg, ok := perConstraintErrors["type"]; ok {
				return jsStringEscape(msg)
			}
		}
		if customError != nil {
			return jsStringEscape(*customError)
		}
		return defaultExpected
	}
	switch numType {
	case "int32":
		e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < -2147483648 || %s > 2147483647))", accessor, accessor, accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("int32"), accessor)
		e.EndBlock()
	case "uint32":
		e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < 0 || %s > 4294967295))", accessor, accessor, accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("uint32"), accessor)
		e.EndBlock()
	case "int64":
		e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < -9007199254740991 || %s > 9007199254740991))", accessor, accessor, accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("int64"), accessor)
		e.EndBlock()
	case "uint64":
		e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < 0 || %s > 9007199254740991))", accessor, accessor, accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("uint64"), accessor)
		e.EndBlock()
	case "float":
		e.Block("if (typeof %s === \"number\" && !Number.isFinite(%s))", accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("float"), accessor)
		e.EndBlock()
	case "double":
		// double always passes — no extra check needed (any finite number is valid)
	}
}

// generateFormatCheck emits validation code for a string format constraint.
// Checks perConstraintErrors["format"] first, then customError (global), then default.
func generateFormatCheck(e *Emitter, accessor string, path string, format string, customError *string, perConstraintErrors map[string]string) {
	errMsg := func(defaultExpected string) string {
		if perConstraintErrors != nil {
			if msg, ok := perConstraintErrors["format"]; ok {
				return jsStringEscape(msg)
			}
		}
		if customError != nil {
			return jsStringEscape(*customError)
		}
		return defaultExpected
	}

	switch format {
	case "password":
		// No validation — any string passes
		return
	case "regex":
		// Use try/catch to validate regex
		e.Block("if (typeof %s === \"string\")", accessor)
		e.Line("try { new RegExp(%s); } catch (_e) { errors.push({ path: %q, expected: \"%s\", received: %s }); }", accessor, path, errMsg("format regex"), accessor)
		e.EndBlock()
		return
	}

	// All other formats use regex validation
	pattern, ok := formatRegexes[format]
	if !ok || pattern == "" {
		return
	}

	flags := formatFlags[format]
	var regexLiteral string
	if flags != "" {
		regexLiteral = fmt.Sprintf("/%s/%s", pattern, flags)
	} else {
		regexLiteral = fmt.Sprintf("/%s/", pattern)
	}

	e.Block("if (typeof %s === \"string\" && !%s.test(%s))", accessor, regexLiteral, accessor)
	e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg(fmt.Sprintf("format %s", format)), accessor)
	e.EndBlock()
}

func generateArrayCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	e.Block("if (!Array.isArray(%s))", accessor)
	e.Line("errors.push({ path: %q, expected: \"array\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	if meta.ElementType != nil {
		idx := fmt.Sprintf("i%d", depth)
		e.Block("for (let %s = 0; %s < %s.length; %s++)", idx, idx, accessor, idx)
		elemAccessor := fmt.Sprintf("%s[%s]", accessor, idx)
		elemPath := fmt.Sprintf("%s[\" + %s + \"]", path, idx)
		generateTypeCheck(e, elemAccessor, elemPath, meta.ElementType, registry, depth+1, ctx)
		e.EndBlock()
	}

	e.indent--
	e.Line("}")
}

func generateTupleCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	e.Block("if (!Array.isArray(%s))", accessor)
	e.Line("errors.push({ path: %q, expected: \"tuple\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Check required length (count non-optional, non-rest elements)
	minLen := 0
	for _, elem := range meta.Elements {
		if !elem.Optional && !elem.Rest {
			minLen++
		}
	}
	if minLen > 0 {
		e.Block("if (%s.length < %d)", accessor, minLen)
		e.Line("errors.push({ path: %q, expected: \"tuple of length >= %d\", received: %s.length });", path, minLen, accessor)
		e.EndBlock()
	}

	// Check each element
	for i, elem := range meta.Elements {
		if elem.Rest {
			continue // Rest elements are not checked individually
		}
		elemAccessor := fmt.Sprintf("%s[%d]", accessor, i)
		elemPath := fmt.Sprintf("%s[%d]", path, i)
		if elem.Optional {
			e.Block("if (%s.length > %d)", accessor, i)
			generateTypeCheck(e, elemAccessor, elemPath, &elem.Type, registry, depth+1, ctx)
			e.EndBlock()
		} else {
			generateTypeCheck(e, elemAccessor, elemPath, &elem.Type, registry, depth+1, ctx)
		}
	}

	e.indent--
	e.Line("}")
}

func generateUnionCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// For literal unions, generate a Set check
	allLiterals := true
	for _, m := range meta.UnionMembers {
		if m.Kind != metadata.KindLiteral {
			allLiterals = false
			break
		}
	}

	if allLiterals && len(meta.UnionMembers) > 0 {
		vals := make([]string, len(meta.UnionMembers))
		for i, m := range meta.UnionMembers {
			vals[i] = jsLiteral(m.LiteralValue)
		}
		setExpr := "[" + strings.Join(vals, ", ") + "]"
		e.Block("if (!%s.includes(%s))", setExpr, accessor)
		// Use jsStringEscape to safely embed literal values inside a JS string
		escapedDesc := jsStringEscape("one of " + strings.Join(vals, " | "))
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, escapedDesc, accessor)
		e.EndBlock()
		return
	}

	// Discriminated union optimization: emit switch(x[discriminantKey]) instead of try-each.
	if meta.Discriminant != nil && len(meta.Discriminant.Mapping) > 0 {
		generateDiscriminatedUnionCheck(e, accessor, path, meta, registry, depth, ctx)
		return
	}

	// For type unions, try each member — if any passes, the value is valid.
	// We use a "union check" pattern: save errors, try each branch.
	e.Line("const %s = errors.length;", unionSaveVar(depth))
	e.Line("let %s = false;", unionValidVar(depth))

	for i, member := range meta.UnionMembers {
		e.Line("// union member %d", i)
		e.Line("errors.length = %s;", unionSaveVar(depth))
		memberCopy := member
		generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth+1, ctx)
		e.Block("if (errors.length === %s)", unionSaveVar(depth))
		e.Line("%s = true;", unionValidVar(depth))
		e.EndBlock()
	}

	e.Block("if (!%s)", unionValidVar(depth))
	e.Line("errors.length = %s;", unionSaveVar(depth))
	expected := describeUnion(meta)
	e.Line("errors.push({ path: %q, expected: %q, received: typeof %s });", path, expected, accessor)
	e.EndBlock()
}

// generateDiscriminatedUnionCheck emits a switch statement on the discriminant property
// for O(1) dispatch instead of O(n) try-each for discriminated unions.
func generateDiscriminatedUnionCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	disc := meta.Discriminant
	discAccessor := fmt.Sprintf("%s[%q]", accessor, disc.Property)

	// First check the value is an object
	e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
	e.Line("errors.push({ path: %q, expected: \"object\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Build sorted list of discriminant values for deterministic output
	discValues := make([]string, 0, len(disc.Mapping))
	for v := range disc.Mapping {
		discValues = append(discValues, v)
	}
	sort.Strings(discValues)

	e.Line("switch (%s) {", discAccessor)
	e.indent++

	for _, val := range discValues {
		memberIdx := disc.Mapping[val]
		if memberIdx < 0 || memberIdx >= len(meta.UnionMembers) {
			continue
		}
		member := meta.UnionMembers[memberIdx]
		memberCopy := member

		e.Line("case %s:", jsLiteral(val))
		e.indent++
		generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth+1, ctx)
		e.Line("break;")
		e.indent--
	}

	// Default case: unknown discriminant value
	e.Line("default:")
	e.indent++
	expectedVals := make([]string, len(discValues))
	for i, v := range discValues {
		expectedVals[i] = jsLiteral(v)
	}
	expectedStr := jsStringEscape("one of " + strings.Join(expectedVals, " | "))
	e.Line("errors.push({ path: \"%s.%s\", expected: \"%s\", received: %s });", path, disc.Property, expectedStr, discAccessor)
	e.indent--

	e.indent--
	e.Line("}")

	e.EndBlock() // close else block
}

func generateEnumCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata) {
	vals := make([]string, len(meta.EnumValues))
	for i, ev := range meta.EnumValues {
		vals[i] = jsLiteral(ev.Value)
	}
	setExpr := "[" + strings.Join(vals, ", ") + "]"
	e.Block("if (!%s.includes(%s))", setExpr, accessor)
	e.Line("errors.push({ path: %q, expected: \"enum value\", received: %s });", path, accessor)
	e.EndBlock()
}

func generateNativeCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata) {
	switch meta.NativeType {
	case "Date":
		e.Block("if (!(%s instanceof Date) || isNaN(%s.getTime()))", accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"Date\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "RegExp":
		e.Block("if (!(%s instanceof RegExp))", accessor)
		e.Line("errors.push({ path: %q, expected: \"RegExp\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "Map":
		e.Block("if (!(%s instanceof Map))", accessor)
		e.Line("errors.push({ path: %q, expected: \"Map\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "Set":
		e.Block("if (!(%s instanceof Set))", accessor)
		e.Line("errors.push({ path: %q, expected: \"Set\", received: typeof %s });", path, accessor)
		e.EndBlock()
	default:
		// TypedArrays, URL, etc.
		e.Block("if (!(%s instanceof %s))", accessor, meta.NativeType)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: typeof %s });", path, meta.NativeType, accessor)
		e.EndBlock()
	}
}

// --- Helpers ---

func unionSaveVar(depth int) string {
	return fmt.Sprintf("_ue%d", depth)
}

func unionValidVar(depth int) string {
	return fmt.Sprintf("_uv%d", depth)
}

func jsLiteral(v any) string {
	switch val := v.(type) {
	case string:
		return fmt.Sprintf("%q", val)
	case float64:
		return fmt.Sprintf("%v", val)
	case bool:
		if val {
			return "true"
		}
		return "false"
	default:
		return fmt.Sprintf("%v", v)
	}
}

// joinQuoted joins strings as JavaScript quoted values: "a", "b", "c"
func joinQuoted(keys []string) string {
	parts := make([]string, len(keys))
	for i, k := range keys {
		parts[i] = fmt.Sprintf("%q", k)
	}
	return strings.Join(parts, ", ")
}

// defaultToJSLiteral converts a @default string value to an appropriate JS literal.
// The type hint is used to determine parsing:
//   - string type: wraps in quotes ("hello")
//   - number type: outputs as-is (42, 3.14)
//   - boolean type: outputs true/false
//   - "null" string: outputs null
//   - otherwise: wraps in quotes as fallback
func defaultToJSLiteral(raw string, propType *metadata.Metadata) string {
	// Strip surrounding quotes from the raw value if present
	raw = stripDefaultQuotes(raw)

	// Handle explicit null
	if raw == "null" {
		return "null"
	}

	// Determine type from property metadata
	if propType != nil && propType.Kind == metadata.KindAtomic {
		switch propType.Atomic {
		case "number":
			// Validate it looks like a number, output as-is
			raw = strings.TrimSpace(raw)
			if _, err := fmt.Sscanf(raw, "%f", new(float64)); err == nil {
				return raw
			}
			return "0" // fallback for invalid number
		case "boolean":
			raw = strings.TrimSpace(strings.ToLower(raw))
			if raw == "true" {
				return "true"
			}
			return "false"
		}
	}

	// Default: treat as string
	return fmt.Sprintf("\"%s\"", jsStringEscape(raw))
}

// stripDefaultQuotes removes surrounding double or single quotes from a @default value.
func stripDefaultQuotes(s string) string {
	if len(s) >= 2 {
		if (s[0] == '"' && s[len(s)-1] == '"') || (s[0] == '\'' && s[len(s)-1] == '\'') {
			return s[1 : len(s)-1]
		}
	}
	return s
}

// jsStringEscape escapes a string so it can be safely embedded inside a
// JavaScript double-quoted string literal. It escapes double quotes and
// backslashes.
func jsStringEscape(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	return s
}

func describeType(meta *metadata.Metadata) string {
	switch meta.Kind {
	case metadata.KindAtomic:
		return meta.Atomic
	case metadata.KindLiteral:
		return fmt.Sprintf("%v", meta.LiteralValue)
	case metadata.KindObject:
		if meta.Name != "" {
			return meta.Name
		}
		return "object"
	case metadata.KindArray:
		return "array"
	case metadata.KindTuple:
		return "tuple"
	case metadata.KindUnion:
		return describeUnion(meta)
	case metadata.KindRef:
		return meta.Ref
	case metadata.KindNative:
		return meta.NativeType
	default:
		return string(meta.Kind)
	}
}

func describeUnion(meta *metadata.Metadata) string {
	parts := make([]string, len(meta.UnionMembers))
	for i, m := range meta.UnionMembers {
		parts[i] = describeType(&m)
	}
	return strings.Join(parts, " | ")
}

// generateStandardSchemaWrapper generates a Standard Schema v1 wrapper object
// that wraps the validate function for cross-framework interoperability.
func generateStandardSchemaWrapper(e *Emitter, typeName string) {
	schemaName := "schema" + typeName
	validateFn := "validate" + typeName
	e.Line("// Standard Schema v1 wrapper")
	e.Line("export const %s = {", schemaName)
	e.Indent()
	e.Line("\"~standard\": {")
	e.Indent()
	e.Line("version: 1,")
	e.Line("vendor: \"tsgonest\",")
	e.Block("validate(value)")
	e.Line("const result = %s(value);", validateFn)
	e.Block("if (result.success)")
	e.Line("return { value: result.data };")
	e.EndBlock()
	e.Line("return {")
	e.Indent()
	e.Line("issues: result.errors.map(e => ({")
	e.Indent()
	e.Line("message: e.message || (\"Validation failed at \" + e.path),")
	e.Line("path: e.path ? e.path.split(\".\").map(k => ({ key: k })) : []")
	e.Dedent()
	e.Line("}))")
	e.Dedent()
	e.Line("};")
	e.EndBlock() // validate(value)
	e.Dedent()
	e.Line("}")
	e.Dedent()
	e.Line("};")
}
