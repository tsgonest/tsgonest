package codegen

import (
	"fmt"
	"sort"
	"strings"

	"github.com/tsgonest/tsgonest/internal/metadata"
)

// GenerateCompanion generates a consolidated companion file (.tsgonest.js) containing
// validation, assertion, serialization, and Standard Schema functions for a named type.
// This replaces the old separate validate.js + serialize.js files.
func GenerateCompanion(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry) string {
	return GenerateCompanionSelective(typeName, meta, registry, true, true)
}

// GenerateCompanionSelective generates a companion file with optional sections.
// includeValidation controls validate/assert/schema functions.
// includeSerialization controls the serialize function.
func GenerateCompanionSelective(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, includeValidation bool, includeSerialization bool) string {
	e := NewEmitter()
	e.Line("// Auto-generated by tsgonest — do not edit")
	e.Blank()

	if includeValidation {
		// Collect and emit imports for custom validator functions (Validate<typeof fn>)
		imports := collectValidateImports(meta, registry)
		for _, imp := range imports {
			e.Line("import { %s } from %q;", imp.FnName, imp.Module)
		}
		if len(imports) > 0 {
			e.Blank()
		}
	}

	if includeSerialization {
		// Import serialization helpers from shared module instead of inlining them.
		e.Line("import { __s, __sa } from \"./_tsgonest_helpers.js\";")
		e.Blank()
	}

	if includeValidation {
		// Generate is function (pure boolean, zero allocations)
		isCtx := &validateCtx{
			generating: map[string]bool{typeName: true},
		}
		generateIsFunction(e, typeName, meta, registry, isCtx)
		e.Blank()

		// Generate validate function
		ctx := &validateCtx{
			generating: map[string]bool{typeName: true},
		}
		generateValidateFunction(e, typeName, meta, registry, ctx)
		e.Blank()

		// Generate assert function (standalone, throws on first error)
		assertCtx := &validateCtx{
			generating: map[string]bool{typeName: true},
		}
		generateAssertFunction(e, typeName, meta, registry, assertCtx)
		e.Blank()
	}

	if includeSerialization {
		// Generate serialize function
		sCtx := &serializeCtx{
			generating: map[string]bool{typeName: true},
		}
		generateSerializeFunction(e, typeName, meta, registry, sCtx)
		e.Blank()

		// Generate transform function
		tCtx := &transformCtx{
			generating: map[string]bool{typeName: true},
		}
		generateTransformFunction(e, typeName, meta, registry, tCtx)
		e.Blank()
	}

	if includeValidation && includeSerialization {
		// Generate stringify function (validate + serialize combined)
		generateStringifyFunction(e, typeName)
		e.Blank()
	}

	if includeValidation {
		// Generate Standard Schema v1 wrapper
		generateStandardSchemaWrapper(e, typeName)
	}

	return e.String()
}

// GenerateCompanionTypes generates TypeScript declaration (.tsgonest.d.ts) content
// for the consolidated companion file, including Standard Schema v1 type info.
func GenerateCompanionTypes(typeName string) string {
	return GenerateCompanionTypesSelective(typeName, true, true)
}

// GenerateCompanionTypesSelective generates type declarations with optional sections.
func GenerateCompanionTypesSelective(typeName string, includeValidation bool, includeSerialization bool) string {
	e := NewEmitter()
	e.Line("// Auto-generated by tsgonest — do not edit")
	e.Blank()

	if includeValidation {
		// Define the StandardSchemaV1Props interface inline (generic for type inference)
		e.Line("interface StandardSchemaV1Props<Input = unknown, Output = Input> {")
		e.Line("  readonly version: 1;")
		e.Line("  readonly vendor: string;")
		e.Line("  readonly validate: (value: unknown) => { value: Output } | { issues: Array<{ message: string; path?: Array<{ key: string }> }> };")
		e.Line("  readonly types?: { readonly input: Input; readonly output: Output };")
		e.Line("}")
		e.Blank()

		e.Line("export declare function is%s(input: unknown): input is %s;", typeName, typeName)
		validateResult := fmt.Sprintf("{ success: true; data: %s } | { success: false; errors: Array<{ path: string; message: string }> }", typeName)
		e.Line("export declare function validate%s(input: unknown): %s;", typeName, validateResult)
		e.Line("export declare function assert%s(input: unknown): %s;", typeName, typeName)
	}

	if includeSerialization {
		e.Line("export declare function serialize%s(input: %s): string;", typeName, typeName)
		e.Line("export declare function transform%s(input: %s): %s;", typeName, typeName, typeName)
	}

	if includeValidation && includeSerialization {
		e.Line("export declare function stringify%s(input: %s): string;", typeName, typeName)
	}

	if includeValidation {
		e.Line("export declare const schema%s: { readonly \"~standard\": StandardSchemaV1Props<%s, %s> };", typeName, typeName, typeName)
	}

	return e.String()
}

// validateImport represents an import needed for a custom validator function.
type validateImport struct {
	FnName string
	Module string
}

// collectValidateImports scans the metadata tree for Validate<typeof fn> constraints
// and returns unique import entries.
func collectValidateImports(meta *metadata.Metadata, registry *metadata.TypeRegistry) []validateImport {
	seen := make(map[string]bool)
	visitedRefs := make(map[string]bool) // prevent infinite recursion on recursive types
	var imports []validateImport

	var scan func(m *metadata.Metadata)
	scan = func(m *metadata.Metadata) {
		if m == nil {
			return
		}

		switch m.Kind {
		case metadata.KindObject:
			for i := range m.Properties {
				prop := &m.Properties[i]
				if prop.Constraints != nil && prop.Constraints.ValidateFn != nil && prop.Constraints.ValidateModule != nil {
					key := *prop.Constraints.ValidateFn + "|" + *prop.Constraints.ValidateModule
					if !seen[key] {
						seen[key] = true
						imports = append(imports, validateImport{
							FnName: *prop.Constraints.ValidateFn,
							Module: toRelativeImportPath(*prop.Constraints.ValidateModule),
						})
					}
				}
				scan(&prop.Type)
			}
		case metadata.KindArray:
			if m.ElementType != nil {
				scan(m.ElementType)
			}
		case metadata.KindTuple:
			for i := range m.Elements {
				scan(&m.Elements[i].Type)
			}
		case metadata.KindUnion:
			for i := range m.UnionMembers {
				scan(&m.UnionMembers[i])
			}
		case metadata.KindRef:
			if m.Ref != "" && registry != nil && !visitedRefs[m.Ref] {
				visitedRefs[m.Ref] = true
				if resolved, ok := registry.Types[m.Ref]; ok {
					scan(resolved)
				}
			}
		}
	}

	scan(meta)

	// Sort by function name for deterministic output
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].FnName < imports[j].FnName
	})

	return imports
}

// toRelativeImportPath converts a TypeScript source file path to a relative import path.
// Strips the .ts/.tsx extension and ensures it starts with "./" or "../".
func toRelativeImportPath(filePath string) string {
	// Strip .ts/.tsx/.mts/.cts extension
	for _, ext := range []string{".ts", ".tsx", ".mts", ".cts"} {
		if len(filePath) > len(ext) && filePath[len(filePath)-len(ext):] == ext {
			filePath = filePath[:len(filePath)-len(ext)]
			break
		}
	}
	// Ensure relative path prefix
	if !strings.HasPrefix(filePath, ".") && !strings.HasPrefix(filePath, "/") {
		filePath = "./" + filePath
	}
	return filePath
}

// validateCtx tracks codegen state to prevent infinite recursion on recursive types.
type validateCtx struct {
	// generating tracks type names currently being generated to detect recursion.
	generating map[string]bool
}

// generateValidateFunction generates: export function validate<Name>(input) { ... }
// For recursive types, generates an inner function with path+errors parameters
// to avoid expensive regex path rewrites and spread operations.
func generateValidateFunction(e *Emitter, typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, ctx *validateCtx) {
	fnName := "validate" + typeName

	// Check if the type is recursive — if so, use inner function pattern
	isRecursive := isRecursiveType(typeName, meta, registry)

	if isRecursive {
		// Generate inner function that takes path and errors parameters
		innerFn := "_validate" + typeName
		e.Block("function %s(input, _path, errors)", innerFn)
		generateTypeCheckWithPath(e, "input", "_path", meta, registry, 0, ctx)
		e.EndBlock()
		e.Block("export function %s(input)", fnName)
		e.Line("const errors = [];")
		e.Line("%s(input, \"input\", errors);", innerFn)
		e.Block("if (errors.length > 0)")
		e.Line("return { success: false, errors };")
		e.EndBlock()
		e.Line("return { success: true, data: input };")
		e.EndBlock()
	} else {
		e.Block("export function %s(input)", fnName)
		e.Line("const errors = [];")
		generateTypeCheck(e, "input", "", meta, registry, 0, ctx)
		e.Block("if (errors.length > 0)")
		e.Line("return { success: false, errors };")
		e.EndBlock()
		e.Line("return { success: true, data: input };")
		e.EndBlock()
	}
}

// generateTypeCheckWithPath generates validation checks using a dynamic path variable
// instead of hardcoded path strings. Used for recursive type validation.
func generateTypeCheckWithPath(e *Emitter, accessor string, pathExpr string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// Handle nullable/optional
	if meta.Nullable && meta.Optional {
		e.Block("if (%s !== null && %s !== undefined)", accessor, accessor)
		generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Nullable {
		e.Block("if (%s !== null)", accessor)
		generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Optional {
		e.Block("if (%s !== undefined)", accessor)
		generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
}

func generateTypeCheckWithPathInner(e *Emitter, accessor string, pathExpr string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	switch meta.Kind {
	case metadata.KindAtomic:
		switch meta.Atomic {
		case "string":
			e.Block("if (typeof %s !== \"string\")", accessor)
			e.Line("errors.push({ path: %s, expected: \"string\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		case "number":
			e.Block("if (typeof %s !== \"number\" || !Number.isFinite(%s))", accessor, accessor)
			e.Line("errors.push({ path: %s, expected: \"number\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		case "boolean":
			e.Block("if (typeof %s !== \"boolean\")", accessor)
			e.Line("errors.push({ path: %s, expected: \"boolean\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		case "bigint":
			e.Block("if (typeof %s !== \"bigint\")", accessor)
			e.Line("errors.push({ path: %s, expected: \"bigint\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		}

	case metadata.KindObject:
		e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
		e.Line("errors.push({ path: %s, expected: \"object\", received: typeof %s });", pathExpr, accessor)
		e.EndBlockSuffix(" else {")
		e.indent++
		for _, prop := range meta.Properties {
			propAccessor := accessor + "." + prop.Name
			propPathExpr := fmt.Sprintf("%s + \".%s\"", pathExpr, prop.Name)
			if prop.Required && !prop.Type.Optional {
				e.Block("if (%s === undefined)", propAccessor)
				e.Line("errors.push({ path: %s, expected: \"%s\", received: \"undefined\" });", propPathExpr, describeType(&prop.Type))
				e.EndBlockSuffix(" else {")
				e.indent++
				generateTypeCheckWithPath(e, propAccessor, propPathExpr, &prop.Type, registry, depth+1, ctx)
				e.indent--
				e.Line("}")
			} else {
				generateTypeCheckWithPath(e, propAccessor, propPathExpr, &prop.Type, registry, depth+1, ctx)
			}
		}
		e.indent--
		e.Line("}")

	case metadata.KindArray:
		e.Block("if (!Array.isArray(%s))", accessor)
		e.Line("errors.push({ path: %s, expected: \"array\", received: typeof %s });", pathExpr, accessor)
		e.EndBlockSuffix(" else {")
		e.indent++
		if meta.ElementType != nil {
			idx := fmt.Sprintf("i%d", depth)
			e.Block("for (let %s = 0; %s < %s.length; %s++)", idx, idx, accessor, idx)
			elemAccessor := fmt.Sprintf("%s[%s]", accessor, idx)
			elemPathExpr := fmt.Sprintf("%s + \"[\" + %s + \"]\"", pathExpr, idx)
			generateTypeCheckWithPath(e, elemAccessor, elemPathExpr, meta.ElementType, registry, depth+1, ctx)
			e.EndBlock()
		}
		e.indent--
		e.Line("}")

	case metadata.KindRef:
		if ctx != nil && ctx.generating[meta.Ref] {
			// Recursive call — use inner function with shared errors array
			innerFn := "_validate" + meta.Ref
			e.Line("%s(%s, %s, errors);", innerFn, accessor, pathExpr)
		} else if resolved, ok := registry.Types[meta.Ref]; ok {
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			generateTypeCheckWithPath(e, accessor, pathExpr, resolved, registry, depth, ctx)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
		}

	case metadata.KindEnum:
		if len(meta.EnumValues) > 0 {
			vals := make([]string, len(meta.EnumValues))
			for i, ev := range meta.EnumValues {
				vals[i] = jsLiteral(ev.Value)
			}
			setExpr := "[" + strings.Join(vals, ", ") + "]"
			e.Block("if (!%s.includes(%s))", setExpr, accessor)
			e.Line("errors.push({ path: %s, expected: \"enum value\", received: %s });", pathExpr, accessor)
			e.EndBlock()
		}

	case metadata.KindNative:
		switch meta.NativeType {
		case "Date":
			e.Block("if (!(%s instanceof Date) || isNaN(%s.getTime()))", accessor, accessor)
			e.Line("errors.push({ path: %s, expected: \"Date\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		default:
			e.Block("if (!(%s instanceof %s))", accessor, meta.NativeType)
			e.Line("errors.push({ path: %s, expected: \"%s\", received: typeof %s });", pathExpr, meta.NativeType, accessor)
			e.EndBlock()
		}

	case metadata.KindUnion:
		// For recursive validate with path, use the same union pattern but with dynamic path
		// Delegate to the standard generateTypeCheck since unions are complex
		// and the path rewrite is mainly an issue for recursive refs, not unions
		generateUnionCheck(e, accessor, pathExpr, meta, registry, depth, ctx)

	case metadata.KindLiteral:
		e.Block("if (%s !== %s)", accessor, jsLiteral(meta.LiteralValue))
		e.Line("errors.push({ path: %s, expected: %q, received: %s });", pathExpr, fmt.Sprintf("%v", meta.LiteralValue), accessor)
		e.EndBlock()

	case metadata.KindAny, metadata.KindUnknown:
		// No validation

	case metadata.KindNever:
		e.Line("errors.push({ path: %s, expected: \"never\", received: typeof %s });", pathExpr, accessor)

	case metadata.KindVoid:
		e.Block("if (%s !== undefined)", accessor)
		e.Line("errors.push({ path: %s, expected: \"void\", received: typeof %s });", pathExpr, accessor)
		e.EndBlock()

	case metadata.KindIntersection:
		for _, member := range meta.IntersectionMembers {
			memberCopy := member
			generateTypeCheckWithPathInner(e, accessor, pathExpr, &memberCopy, registry, depth, ctx)
		}
	}
}

// generateAssertFunction generates a standalone assert function that throws on first error.
// For non-recursive types: direct inline checks with throw.
// For recursive types: inner function with path parameter.
func generateAssertFunction(e *Emitter, typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, ctx *validateCtx) {
	fnName := "assert" + typeName

	// Check if type is recursive
	isRecursive := isRecursiveType(typeName, meta, registry)

	if isRecursive {
		// Generate inner function with path parameter
		innerFn := "_assert" + typeName
		e.Block("function %s(input, _path)", innerFn)
		generateAssertChecks(e, "input", "_path", meta, registry, 0, ctx, true)
		e.Line("return input;")
		e.EndBlock()
		e.Block("export function %s(input)", fnName)
		e.Line("return %s(input, \"input\");", innerFn)
		e.EndBlock()
	} else {
		e.Block("export function %s(input)", fnName)
		generateAssertChecks(e, "input", "\"input\"", meta, registry, 0, ctx, false)
		e.Line("return input;")
		e.EndBlock()
	}
}

// generateAssertChecks generates throw-on-first-error checks for assertX().
func generateAssertChecks(e *Emitter, accessor string, pathExpr string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx, isRecursive bool) {
	// Handle nullable/optional
	if meta.Nullable && meta.Optional {
		e.Block("if (%s !== null && %s !== undefined)", accessor, accessor)
		generateAssertChecksInner(e, accessor, pathExpr, meta, registry, depth, ctx, isRecursive)
		e.EndBlock()
		return
	}
	if meta.Nullable {
		e.Block("if (%s !== null)", accessor)
		generateAssertChecksInner(e, accessor, pathExpr, meta, registry, depth, ctx, isRecursive)
		e.EndBlock()
		return
	}
	if meta.Optional {
		e.Block("if (%s !== undefined)", accessor)
		generateAssertChecksInner(e, accessor, pathExpr, meta, registry, depth, ctx, isRecursive)
		e.EndBlock()
		return
	}
	generateAssertChecksInner(e, accessor, pathExpr, meta, registry, depth, ctx, isRecursive)
}

func generateAssertChecksInner(e *Emitter, accessor string, pathExpr string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx, isRecursive bool) {
	switch meta.Kind {
	case metadata.KindAtomic:
		switch meta.Atomic {
		case "string":
			e.Block("if (typeof %s !== \"string\")", accessor)
			e.Line("throw new TypeError(\"Expected string at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
			e.EndBlock()
		case "number":
			e.Block("if (typeof %s !== \"number\" || !Number.isFinite(%s))", accessor, accessor)
			e.Line("throw new TypeError(\"Expected number at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
			e.EndBlock()
		case "boolean":
			e.Block("if (typeof %s !== \"boolean\")", accessor)
			e.Line("throw new TypeError(\"Expected boolean at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
			e.EndBlock()
		case "bigint":
			e.Block("if (typeof %s !== \"bigint\")", accessor)
			e.Line("throw new TypeError(\"Expected bigint at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
			e.EndBlock()
		}
		if meta.Atomic == "string" && meta.TemplatePattern != "" {
			e.Block("if (typeof %s === \"string\" && !/%s/.test(%s))", accessor, meta.TemplatePattern, accessor)
			e.Line("throw new TypeError(\"Expected pattern %s at \" + %s);", jsStringEscape(meta.TemplatePattern), pathExpr)
			e.EndBlock()
		}

	case metadata.KindLiteral:
		e.Block("if (%s !== %s)", accessor, jsLiteral(meta.LiteralValue))
		e.Line("throw new TypeError(\"Expected %s at \" + %s + \", received \" + %s);", jsStringEscape(fmt.Sprintf("%v", meta.LiteralValue)), pathExpr, accessor)
		e.EndBlock()

	case metadata.KindObject:
		e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
		e.Line("throw new TypeError(\"Expected object at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
		e.EndBlockSuffix(" else {")
		e.indent++
		for _, prop := range meta.Properties {
			propAccessor := accessor + "." + prop.Name
			var propPathExpr string
			if isRecursive {
				propPathExpr = fmt.Sprintf("%s + \".%s\"", pathExpr, prop.Name)
			} else {
				propPathExpr = fmt.Sprintf("%s + \".%s\"", pathExpr, prop.Name)
			}
			if prop.Required && !prop.Type.Optional {
				e.Block("if (%s === undefined)", propAccessor)
				e.Line("throw new TypeError(\"Expected %s at \" + %s + \", received undefined\");", describeType(&prop.Type), propPathExpr)
				e.EndBlockSuffix(" else {")
				e.indent++
				generateAssertChecks(e, propAccessor, propPathExpr, &prop.Type, registry, depth+1, ctx, isRecursive)
				generateAssertConstraintChecks(e, propAccessor, propPathExpr, &prop)
				e.indent--
				e.Line("}")
			} else if prop.ExactOptional {
				e.Block("if (%q in %s)", prop.Name, accessor)
				e.Block("if (%s === undefined)", propAccessor)
				e.Line("throw new TypeError(\"Expected %s at \" + %s + \", received explicit undefined\");", describeType(&prop.Type), propPathExpr)
				e.EndBlockSuffix(" else {")
				e.indent++
				generateAssertChecks(e, propAccessor, propPathExpr, &prop.Type, registry, depth+1, ctx, isRecursive)
				generateAssertConstraintChecks(e, propAccessor, propPathExpr, &prop)
				e.indent--
				e.Line("}")
				e.EndBlock()
			} else {
				generateAssertChecks(e, propAccessor, propPathExpr, &prop.Type, registry, depth+1, ctx, isRecursive)
				if prop.Constraints != nil {
					if prop.Type.Optional || !prop.Required {
						e.Block("if (%s !== undefined)", propAccessor)
						generateAssertConstraintChecks(e, propAccessor, propPathExpr, &prop)
						e.EndBlock()
					} else {
						generateAssertConstraintChecks(e, propAccessor, propPathExpr, &prop)
					}
				}
			}
		}
		e.indent--
		e.Line("}")

	case metadata.KindArray:
		e.Block("if (!Array.isArray(%s))", accessor)
		e.Line("throw new TypeError(\"Expected array at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
		e.EndBlockSuffix(" else {")
		e.indent++
		if meta.ElementType != nil {
			idx := fmt.Sprintf("i%d", depth)
			e.Block("for (let %s = 0; %s < %s.length; %s++)", idx, idx, accessor, idx)
			elemAccessor := fmt.Sprintf("%s[%s]", accessor, idx)
			elemPathExpr := fmt.Sprintf("%s + \"[\" + %s + \"]\"", pathExpr, idx)
			generateAssertChecks(e, elemAccessor, elemPathExpr, meta.ElementType, registry, depth+1, ctx, isRecursive)
			e.EndBlock()
		}
		e.indent--
		e.Line("}")

	case metadata.KindTuple:
		e.Block("if (!Array.isArray(%s))", accessor)
		e.Line("throw new TypeError(\"Expected tuple at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
		e.EndBlock()
		for i, elem := range meta.Elements {
			if elem.Rest {
				continue
			}
			elemAccessor := fmt.Sprintf("%s[%d]", accessor, i)
			elemPathExpr := fmt.Sprintf("%s + \"[%d]\"", pathExpr, i)
			if elem.Optional {
				e.Block("if (%s.length > %d)", accessor, i)
				generateAssertChecks(e, elemAccessor, elemPathExpr, &elem.Type, registry, depth+1, ctx, isRecursive)
				e.EndBlock()
			} else {
				generateAssertChecks(e, elemAccessor, elemPathExpr, &elem.Type, registry, depth+1, ctx, isRecursive)
			}
		}

	case metadata.KindUnion:
		// For literal unions, inline check
		allLit := true
		for _, m := range meta.UnionMembers {
			if m.Kind != metadata.KindLiteral {
				allLit = false
				break
			}
		}
		if allLit && len(meta.UnionMembers) > 0 {
			vals := make([]string, len(meta.UnionMembers))
			for i, m := range meta.UnionMembers {
				vals[i] = jsLiteral(m.LiteralValue)
			}
			checks := make([]string, len(vals))
			for i, v := range vals {
				checks[i] = fmt.Sprintf("%s === %s", accessor, v)
			}
			e.Block("if (!(%s))", strings.Join(checks, " || "))
			e.Line("throw new TypeError(\"Expected one of %s at \" + %s + \", received \" + %s);", jsStringEscape(strings.Join(vals, " | ")), pathExpr, accessor)
			e.EndBlock()
		} else {
			// For complex unions, delegate to validate + throw
			e.Line("// complex union — delegate to validate")
		}

	case metadata.KindRef:
		if ctx != nil && ctx.generating[meta.Ref] {
			// Recursive ref — call inner assert function
			innerFn := "_assert" + meta.Ref
			e.Line("%s(%s, %s);", innerFn, accessor, pathExpr)
		} else if resolved, ok := registry.Types[meta.Ref]; ok {
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			generateAssertChecks(e, accessor, pathExpr, resolved, registry, depth, ctx, isRecursive)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
		}

	case metadata.KindEnum:
		if len(meta.EnumValues) > 0 {
			vals := make([]string, len(meta.EnumValues))
			for i, ev := range meta.EnumValues {
				vals[i] = jsLiteral(ev.Value)
			}
			setExpr := "[" + strings.Join(vals, ", ") + "]"
			e.Block("if (!%s.includes(%s))", setExpr, accessor)
			e.Line("throw new TypeError(\"Expected enum value at \" + %s + \", received \" + %s);", pathExpr, accessor)
			e.EndBlock()
		}

	case metadata.KindNative:
		switch meta.NativeType {
		case "Date":
			e.Block("if (!(%s instanceof Date) || isNaN(%s.getTime()))", accessor, accessor)
			e.Line("throw new TypeError(\"Expected Date at \" + %s + \", received \" + typeof %s);", pathExpr, accessor)
			e.EndBlock()
		default:
			e.Block("if (!(%s instanceof %s))", accessor, meta.NativeType)
			e.Line("throw new TypeError(\"Expected %s at \" + %s + \", received \" + typeof %s);", meta.NativeType, pathExpr, accessor)
			e.EndBlock()
		}

	case metadata.KindAny, metadata.KindUnknown:
		// No validation

	case metadata.KindNever:
		e.Line("throw new TypeError(\"Expected never at \" + %s);", pathExpr)

	case metadata.KindVoid:
		e.Block("if (%s !== undefined)", accessor)
		e.Line("throw new TypeError(\"Expected void at \" + %s);", pathExpr)
		e.EndBlock()

	case metadata.KindIntersection:
		for _, member := range meta.IntersectionMembers {
			memberCopy := member
			generateAssertChecksInner(e, accessor, pathExpr, &memberCopy, registry, depth, ctx, isRecursive)
		}
	}
}

// generateAssertConstraintChecks emits assert-style constraint checks (throw on first failure).
// Uses custom error messages when configured (per-constraint or global).
func generateAssertConstraintChecks(e *Emitter, accessor string, pathExpr string, prop *metadata.Property) {
	c := prop.Constraints
	if c == nil {
		return
	}

	// Error message helper matching validate behavior
	errMsg := func(constraintKey string, defaultMsg string) string {
		if c.Errors != nil {
			if msg, ok := c.Errors[constraintKey]; ok {
				return jsStringEscape(msg)
			}
		}
		if c.ErrorMessage != nil {
			return jsStringEscape(*c.ErrorMessage)
		}
		return defaultMsg
	}

	if c.Minimum != nil {
		e.Block("if (typeof %s === \"number\" && %s < %v)", accessor, accessor, *c.Minimum)
		e.Line("throw new TypeError(\"%s at \" + %s + \", got \" + %s);", errMsg("minimum", fmt.Sprintf("Expected minimum %v", *c.Minimum)), pathExpr, accessor)
		e.EndBlock()
	}
	if c.Maximum != nil {
		e.Block("if (typeof %s === \"number\" && %s > %v)", accessor, accessor, *c.Maximum)
		e.Line("throw new TypeError(\"%s at \" + %s + \", got \" + %s);", errMsg("maximum", fmt.Sprintf("Expected maximum %v", *c.Maximum)), pathExpr, accessor)
		e.EndBlock()
	}
	if c.MinLength != nil {
		e.Block("if (typeof %s === \"string\" && %s.length < %d)", accessor, accessor, *c.MinLength)
		e.Line("throw new TypeError(\"%s at \" + %s + \", got length \" + %s.length);", errMsg("minLength", fmt.Sprintf("Expected minLength %d", *c.MinLength)), pathExpr, accessor)
		e.EndBlock()
	}
	if c.MaxLength != nil {
		e.Block("if (typeof %s === \"string\" && %s.length > %d)", accessor, accessor, *c.MaxLength)
		e.Line("throw new TypeError(\"%s at \" + %s + \", got length \" + %s.length);", errMsg("maxLength", fmt.Sprintf("Expected maxLength %d", *c.MaxLength)), pathExpr, accessor)
		e.EndBlock()
	}
	if c.Pattern != nil {
		e.Block("if (typeof %s === \"string\" && !/%s/.test(%s))", accessor, *c.Pattern, accessor)
		e.Line("throw new TypeError(\"%s at \" + %s);", errMsg("pattern", fmt.Sprintf("Expected pattern %s", jsStringEscape(*c.Pattern))), pathExpr)
		e.EndBlock()
	}
	if c.Format != nil {
		pattern, ok := formatRegexes[*c.Format]
		if ok && pattern != "" {
			flags := formatFlags[*c.Format]
			var regexLiteral string
			if flags != "" {
				regexLiteral = fmt.Sprintf("/%s/%s", pattern, flags)
			} else {
				regexLiteral = fmt.Sprintf("/%s/", pattern)
			}
			e.Block("if (typeof %s === \"string\" && !%s.test(%s))", accessor, regexLiteral, accessor)
			e.Line("throw new TypeError(\"%s at \" + %s);", errMsg("format", fmt.Sprintf("Expected format %s", *c.Format)), pathExpr)
			e.EndBlock()
		}
	}
}

// isRecursiveType checks if a type contains a recursive reference to itself.
func isRecursiveType(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry) bool {
	visited := map[string]bool{typeName: true}
	return hasRecursiveRef(meta, registry, visited, typeName)
}

func hasRecursiveRef(meta *metadata.Metadata, registry *metadata.TypeRegistry, visited map[string]bool, target string) bool {
	if meta == nil {
		return false
	}
	switch meta.Kind {
	case metadata.KindRef:
		if meta.Ref == target {
			return true
		}
		if visited[meta.Ref] {
			return false
		}
		visited[meta.Ref] = true
		if resolved, ok := registry.Types[meta.Ref]; ok {
			return hasRecursiveRef(resolved, registry, visited, target)
		}
	case metadata.KindObject:
		for i := range meta.Properties {
			if hasRecursiveRef(&meta.Properties[i].Type, registry, visited, target) {
				return true
			}
		}
	case metadata.KindArray:
		return hasRecursiveRef(meta.ElementType, registry, visited, target)
	case metadata.KindTuple:
		for i := range meta.Elements {
			if hasRecursiveRef(&meta.Elements[i].Type, registry, visited, target) {
				return true
			}
		}
	case metadata.KindUnion:
		for i := range meta.UnionMembers {
			if hasRecursiveRef(&meta.UnionMembers[i], registry, visited, target) {
				return true
			}
		}
	case metadata.KindIntersection:
		for i := range meta.IntersectionMembers {
			if hasRecursiveRef(&meta.IntersectionMembers[i], registry, visited, target) {
				return true
			}
		}
	}
	return false
}

// generateIsFunction generates a pure boolean type-check function with zero allocations.
// Returns a single expression composed with && chains.
func generateIsFunction(e *Emitter, typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, ctx *validateCtx) {
	fnName := "is" + typeName
	e.Block("export function %s(input)", fnName)
	expr := generateIsExpr("input", meta, registry, 0, ctx)
	e.Line("return %s;", expr)
	e.EndBlock()
}

// generateIsExpr returns a JS boolean expression that checks if the value at `accessor`
// matches the given type. Composes with && for objects, || for unions.
func generateIsExpr(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) string {
	// Handle nullable/optional wrapping
	if meta.Nullable && meta.Optional {
		inner := *meta
		inner.Nullable = false
		inner.Optional = false
		innerExpr := generateIsExpr(accessor, &inner, registry, depth, ctx)
		return fmt.Sprintf("(%s === null || %s === undefined || %s)", accessor, accessor, innerExpr)
	}
	if meta.Nullable {
		inner := *meta
		inner.Nullable = false
		innerExpr := generateIsExpr(accessor, &inner, registry, depth, ctx)
		return fmt.Sprintf("(%s === null || %s)", accessor, innerExpr)
	}
	if meta.Optional {
		inner := *meta
		inner.Optional = false
		innerExpr := generateIsExpr(accessor, &inner, registry, depth, ctx)
		return fmt.Sprintf("(%s === undefined || %s)", accessor, innerExpr)
	}

	return generateIsExprInner(accessor, meta, registry, depth, ctx)
}

func generateIsExprInner(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) string {
	switch meta.Kind {
	case metadata.KindAtomic:
		return generateIsAtomicExpr(accessor, meta)

	case metadata.KindLiteral:
		return fmt.Sprintf("%s === %s", accessor, jsLiteral(meta.LiteralValue))

	case metadata.KindObject:
		return generateIsObjectExpr(accessor, meta, registry, depth, ctx)

	case metadata.KindArray:
		return generateIsArrayExpr(accessor, meta, registry, depth, ctx)

	case metadata.KindTuple:
		parts := []string{fmt.Sprintf("Array.isArray(%s)", accessor)}
		for i, elem := range meta.Elements {
			if elem.Rest {
				continue
			}
			elemAccessor := fmt.Sprintf("%s[%d]", accessor, i)
			if elem.Optional {
				parts = append(parts, fmt.Sprintf("(%s.length <= %d || %s)", accessor, i, generateIsExpr(elemAccessor, &elem.Type, registry, depth+1, ctx)))
			} else {
				parts = append(parts, generateIsExpr(elemAccessor, &elem.Type, registry, depth+1, ctx))
			}
		}
		return "(" + strings.Join(parts, " && ") + ")"

	case metadata.KindUnion:
		return generateIsUnionExpr(accessor, meta, registry, depth, ctx)

	case metadata.KindRef:
		if ctx != nil && ctx.generating[meta.Ref] {
			// Recursive ref — call is function
			return fmt.Sprintf("is%s(%s)", meta.Ref, accessor)
		}
		if resolved, ok := registry.Types[meta.Ref]; ok {
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			result := generateIsExpr(accessor, resolved, registry, depth, ctx)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
			return result
		}
		return "true"

	case metadata.KindEnum:
		if len(meta.EnumValues) > 0 {
			vals := make([]string, len(meta.EnumValues))
			for i, ev := range meta.EnumValues {
				vals[i] = fmt.Sprintf("%s === %s", accessor, jsLiteral(ev.Value))
			}
			return "(" + strings.Join(vals, " || ") + ")"
		}
		return "true"

	case metadata.KindNative:
		switch meta.NativeType {
		case "Date":
			return fmt.Sprintf("(%s instanceof Date && !isNaN(%s.getTime()))", accessor, accessor)
		default:
			return fmt.Sprintf("(%s instanceof %s)", accessor, meta.NativeType)
		}

	case metadata.KindAny, metadata.KindUnknown:
		return "true"

	case metadata.KindNever:
		return "false"

	case metadata.KindVoid:
		return fmt.Sprintf("%s === undefined", accessor)

	case metadata.KindIntersection:
		parts := make([]string, len(meta.IntersectionMembers))
		for i, member := range meta.IntersectionMembers {
			memberCopy := member
			parts[i] = generateIsExprInner(accessor, &memberCopy, registry, depth+1, ctx)
		}
		if len(parts) == 0 {
			return "true"
		}
		return "(" + strings.Join(parts, " && ") + ")"

	default:
		return "true"
	}
}

func generateIsAtomicExpr(accessor string, meta *metadata.Metadata) string {
	var parts []string
	switch meta.Atomic {
	case "string":
		parts = append(parts, fmt.Sprintf("typeof %s === \"string\"", accessor))
	case "number":
		parts = append(parts, fmt.Sprintf("typeof %s === \"number\" && Number.isFinite(%s)", accessor, accessor))
	case "boolean":
		parts = append(parts, fmt.Sprintf("typeof %s === \"boolean\"", accessor))
	case "bigint":
		parts = append(parts, fmt.Sprintf("typeof %s === \"bigint\"", accessor))
	default:
		return "true"
	}
	if meta.Atomic == "string" && meta.TemplatePattern != "" {
		parts = append(parts, fmt.Sprintf("/%s/.test(%s)", meta.TemplatePattern, accessor))
	}
	return strings.Join(parts, " && ")
}

func generateIsObjectExpr(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) string {
	parts := []string{fmt.Sprintf("typeof %s === \"object\" && %s !== null", accessor, accessor)}
	for _, prop := range meta.Properties {
		propAccessor := accessor + "." + prop.Name
		if prop.Required && !prop.Type.Optional {
			parts = append(parts, fmt.Sprintf("%s !== undefined", propAccessor))
			parts = append(parts, generateIsExpr(propAccessor, &prop.Type, registry, depth+1, ctx))
		} else {
			// Optional — only validate if present
			innerExpr := generateIsExpr(propAccessor, &prop.Type, registry, depth+1, ctx)
			if prop.ExactOptional {
				parts = append(parts, fmt.Sprintf("(!(%q in %s) || %s)", prop.Name, accessor, innerExpr))
			} else {
				parts = append(parts, fmt.Sprintf("(%s === undefined || %s)", propAccessor, innerExpr))
			}
		}
		// Inline constraint checks for is()
		if prop.Constraints != nil {
			constraintExprs := generateIsConstraintExprs(propAccessor, &prop)
			parts = append(parts, constraintExprs...)
		}
	}
	return "(" + strings.Join(parts, " && ") + ")"
}

// generateIsConstraintExprs returns JS boolean expressions for constraints.
func generateIsConstraintExprs(accessor string, prop *metadata.Property) []string {
	c := prop.Constraints
	if c == nil {
		return nil
	}
	var exprs []string

	if c.Minimum != nil {
		exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"number\" || %s >= %v)", accessor, accessor, *c.Minimum))
	}
	if c.Maximum != nil {
		exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"number\" || %s <= %v)", accessor, accessor, *c.Maximum))
	}
	if c.ExclusiveMinimum != nil {
		exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"number\" || %s > %v)", accessor, accessor, *c.ExclusiveMinimum))
	}
	if c.ExclusiveMaximum != nil {
		exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"number\" || %s < %v)", accessor, accessor, *c.ExclusiveMaximum))
	}
	if c.MinLength != nil {
		exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"string\" || %s.length >= %d)", accessor, accessor, *c.MinLength))
	}
	if c.MaxLength != nil {
		exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"string\" || %s.length <= %d)", accessor, accessor, *c.MaxLength))
	}
	if c.Pattern != nil {
		exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"string\" || /%s/.test(%s))", accessor, *c.Pattern, accessor))
	}
	if c.Format != nil {
		pattern, ok := formatRegexes[*c.Format]
		if ok && pattern != "" {
			flags := formatFlags[*c.Format]
			var regexLiteral string
			if flags != "" {
				regexLiteral = fmt.Sprintf("/%s/%s", pattern, flags)
			} else {
				regexLiteral = fmt.Sprintf("/%s/", pattern)
			}
			exprs = append(exprs, fmt.Sprintf("(typeof %s !== \"string\" || %s.test(%s))", accessor, regexLiteral, accessor))
		}
	}

	return exprs
}

func generateIsArrayExpr(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) string {
	if meta.ElementType == nil {
		return fmt.Sprintf("Array.isArray(%s)", accessor)
	}
	elemVar := fmt.Sprintf("_v%d", depth)
	elemExpr := generateIsExpr(elemVar, meta.ElementType, registry, depth+1, ctx)
	return fmt.Sprintf("(Array.isArray(%s) && %s.every(%s => %s))", accessor, accessor, elemVar, elemExpr)
}

func generateIsUnionExpr(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) string {
	// Literal unions: direct === checks
	allLit := true
	for _, m := range meta.UnionMembers {
		if m.Kind != metadata.KindLiteral {
			allLit = false
			break
		}
	}
	if allLit && len(meta.UnionMembers) > 0 {
		checks := make([]string, len(meta.UnionMembers))
		for i, m := range meta.UnionMembers {
			checks[i] = fmt.Sprintf("%s === %s", accessor, jsLiteral(m.LiteralValue))
		}
		return "(" + strings.Join(checks, " || ") + ")"
	}

	// Discriminated unions
	if meta.Discriminant != nil && len(meta.Discriminant.Mapping) > 0 {
		return generateIsDiscriminatedUnionExpr(accessor, meta, registry, depth, ctx)
	}

	// General unions: || of member checks
	parts := make([]string, len(meta.UnionMembers))
	for i, m := range meta.UnionMembers {
		memberCopy := m
		parts[i] = generateIsExprInner(accessor, &memberCopy, registry, depth+1, ctx)
	}
	return "(" + strings.Join(parts, " || ") + ")"
}

func generateIsDiscriminatedUnionExpr(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) string {
	// Use IIFE with switch for discriminated unions
	disc := meta.Discriminant
	discAccessor := fmt.Sprintf("%s[%q]", accessor, disc.Property)

	keys := make([]string, 0, len(disc.Mapping))
	for k := range disc.Mapping {
		keys = append(keys, k)
	}
	sort.Strings(keys)

	var parts []string
	parts = append(parts, fmt.Sprintf("(typeof %s === \"object\" && %s !== null && (function() { switch (%s) {", accessor, accessor, discAccessor))
	for _, val := range keys {
		idx := disc.Mapping[val]
		if idx < 0 || idx >= len(meta.UnionMembers) {
			continue
		}
		member := meta.UnionMembers[idx]
		memberExpr := generateIsExprInner(accessor, &member, registry, depth+1, ctx)
		parts = append(parts, fmt.Sprintf("case %s: return %s;", jsLiteral(val), memberExpr))
	}
	parts = append(parts, "default: return false; } }()))")
	return strings.Join(parts, " ")
}

// generateStringifyFunction generates a combined validate+serialize function.
func generateStringifyFunction(e *Emitter, typeName string) {
	fnName := "stringify" + typeName
	validateFn := "validate" + typeName
	serializeFn := "serialize" + typeName
	e.Block("export function %s(input)", fnName)
	e.Line("const r = %s(input);", validateFn)
	e.Block("if (!r.success)")
	e.Line("const e = new TypeError(\"Serialization type check failed for %s\");", typeName)
	e.Line("e.errors = r.errors;")
	e.Line("throw e;")
	e.EndBlock()
	e.Line("return %s(input);", serializeFn)
	e.EndBlock()
}

// generateTypeCheck generates validation checks for a type at the given access path.
// `accessor` is the JS expression to access the value (e.g., "input", "input.name").
// `path` is the error path string (e.g., "input.name").
func generateTypeCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	if path == "" {
		path = accessor
	}

	// Handle nullable
	if meta.Nullable && meta.Optional {
		e.Block("if (%s !== null && %s !== undefined)", accessor, accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Nullable {
		e.Block("if (%s !== null)", accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Optional {
		e.Block("if (%s !== undefined)", accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}

	generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
}

// generateTypeCheckInner generates the actual type checks (after null/undefined handling).
func generateTypeCheckInner(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	switch meta.Kind {
	case metadata.KindAtomic:
		generateAtomicCheck(e, accessor, path, meta.Atomic)
		// Template literal types produce a regex pattern — validate it at runtime
		if meta.Atomic == "string" && meta.TemplatePattern != "" {
			e.Block("if (typeof %s === \"string\" && !/%s/.test(%s))", accessor, meta.TemplatePattern, accessor)
			e.Line("errors.push({ path: %q, expected: \"pattern %s\", received: %s });", path, jsStringEscape(meta.TemplatePattern), accessor)
			e.EndBlock()
		}

	case metadata.KindLiteral:
		generateLiteralCheck(e, accessor, path, meta.LiteralValue)

	case metadata.KindObject:
		generateObjectCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindArray:
		generateArrayCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindTuple:
		generateTupleCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindUnion:
		generateUnionCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindRef:
		// For recursive references (type currently being generated),
		// emit a recursive function call instead of inlining to prevent
		// infinite recursion during codegen.
		if ctx != nil && ctx.generating[meta.Ref] {
			// Emit a recursive call to the validate function being generated
			fnName := "validate" + meta.Ref
			e.Line("{ const _r = %s(%s); if (!_r.success) errors.push(..._r.errors.map(e => ({ ...e, path: e.path.replace(/^input/, %q) }))); }", fnName, accessor, path)
		} else if resolved, ok := registry.Types[meta.Ref]; ok {
			// Non-recursive ref: inline the checks as before
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			generateTypeCheck(e, accessor, path, resolved, registry, depth, ctx)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
		}

	case metadata.KindEnum:
		// Enum types are handled as unions of their literal values
		if len(meta.EnumValues) > 0 {
			generateEnumCheck(e, accessor, path, meta)
		}

	case metadata.KindNative:
		generateNativeCheck(e, accessor, path, meta)

	case metadata.KindAny, metadata.KindUnknown:
		// No validation for any/unknown

	case metadata.KindNever:
		e.Line("errors.push({ path: %q, expected: \"never\", received: typeof %s });", path, accessor)

	case metadata.KindVoid:
		e.Block("if (%s !== undefined)", accessor)
		e.Line("errors.push({ path: %q, expected: \"void\", received: typeof %s });", path, accessor)
		e.EndBlock()

	case metadata.KindIntersection:
		// Intersection: all members must pass validation
		for _, member := range meta.IntersectionMembers {
			memberCopy := member
			generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth, ctx)
		}
	}
}

func generateAtomicCheck(e *Emitter, accessor string, path string, atomic string) {
	switch atomic {
	case "string":
		e.Block("if (typeof %s !== \"string\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"string\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "number":
		e.Block("if (typeof %s !== \"number\" || !Number.isFinite(%s))", accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"number\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "boolean":
		e.Block("if (typeof %s !== \"boolean\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"boolean\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "bigint":
		e.Block("if (typeof %s !== \"bigint\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"bigint\", received: typeof %s });", path, accessor)
		e.EndBlock()
	}
}

func generateLiteralCheck(e *Emitter, accessor string, path string, value any) {
	switch v := value.(type) {
	case string:
		e.Block("if (%s !== %q)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %q, received: %s });", path, v, accessor)
		e.EndBlock()
	case float64:
		e.Block("if (%s !== %v)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %v, received: %s });", path, v, accessor)
		e.EndBlock()
	case bool:
		e.Block("if (%s !== %v)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %v, received: %s });", path, v, accessor)
		e.EndBlock()
	}
}

func generateObjectCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// Check it's an object
	e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
	e.Line("errors.push({ path: %q, expected: \"object\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Handle object strictness
	if meta.Strictness == "strict" || meta.Strictness == "strip" {
		// Build known keys set
		knownKeys := make([]string, 0, len(meta.Properties))
		for _, prop := range meta.Properties {
			knownKeys = append(knownKeys, prop.Name)
		}
		knownSetExpr := "new Set([" + joinQuoted(knownKeys) + "])"

		if meta.Strictness == "strict" {
			// Strict: reject unknown properties
			kVar := fmt.Sprintf("_k%d", depth)
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
			e.Line("errors.push({ path: %q + \".\" + %s, expected: \"known property\", received: %s });", path, kVar, kVar)
			e.EndBlock()
			e.EndBlock()
		} else if meta.Strictness == "strip" {
			// Strip: remove unknown properties
			kVar := fmt.Sprintf("_k%d", depth)
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
			e.Line("delete %s[%s];", accessor, kVar)
			e.EndBlock()
			e.EndBlock()
		}
	}

	// Check each property
	for _, prop := range meta.Properties {
		propAccessor := accessor + "." + prop.Name
		propPath := path + "." + prop.Name

		// Emit default value assignment BEFORE validation.
		// When a property has @default and the value is undefined, fill it in.
		if prop.Constraints != nil && prop.Constraints.Default != nil {
			jsDefault := defaultToJSLiteral(*prop.Constraints.Default, &prop.Type)
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("%s = %s;", propAccessor, jsDefault)
			e.EndBlock()
		}

		if prop.Required && !prop.Type.Optional {
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("errors.push({ path: %q, expected: \"%s\", received: \"undefined\" });", propPath, describeType(&prop.Type))
			e.EndBlockSuffix(" else {")
			e.indent++
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			// After type check, emit constraint checks.
			// When the base type is atomic, the typeof check was already done
			// by generateAtomicCheck, so constraints can skip the typeof guard.
			if prop.Constraints != nil {
				if isAtomicType(&prop.Type) {
					generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
				} else {
					generateConstraintChecks(e, propAccessor, propPath, &prop)
				}
			}
			e.indent--
			e.Line("}")
		} else if prop.ExactOptional {
			// exactOptionalPropertyTypes: property can be missing but not explicitly undefined
			e.Block("if (%q in %s)", prop.Name, accessor)
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("errors.push({ path: %q, expected: \"%s (not undefined)\", received: \"undefined\" });", propPath, describeType(&prop.Type))
			e.EndBlockSuffix(" else {")
			e.indent++
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			if prop.Constraints != nil {
				if isAtomicType(&prop.Type) {
					generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
				} else {
					generateConstraintChecks(e, propAccessor, propPath, &prop)
				}
			}
			e.indent--
			e.Line("}")
			e.EndBlock()
		} else {
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			// After type check, emit constraint checks (only if value is present)
			if prop.Constraints != nil {
				if prop.Type.Optional || !prop.Required {
					e.Block("if (%s !== undefined)", propAccessor)
					if isAtomicType(&prop.Type) {
						generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
					} else {
						generateConstraintChecks(e, propAccessor, propPath, &prop)
					}
					e.EndBlock()
				} else {
					if isAtomicType(&prop.Type) {
						generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
					} else {
						generateConstraintChecks(e, propAccessor, propPath, &prop)
					}
				}
			}
		}
	}

	// Index signature validation: for objects with [key: string]: T,
	// validate that all keys not in the declared properties have values matching T.
	if meta.IndexSignature != nil {
		kVar := fmt.Sprintf("_ik%d", depth)
		// Build set of known property names to exclude
		if len(meta.Properties) > 0 {
			knownKeys := make([]string, 0, len(meta.Properties))
			for _, prop := range meta.Properties {
				knownKeys = append(knownKeys, prop.Name)
			}
			knownSetExpr := "new Set([" + joinQuoted(knownKeys) + "])"
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
		} else {
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
		}

		elemAccessor := fmt.Sprintf("%s[%s]", accessor, kVar)
		elemPath := fmt.Sprintf("%s[\" + %s + \"]", path, kVar)
		generateTypeCheck(e, elemAccessor, elemPath, &meta.IndexSignature.ValueType, registry, depth+1, ctx)

		if len(meta.Properties) > 0 {
			e.EndBlock() // close the if (!knownSet.has) block
		}
		e.EndBlock() // close the for loop
	}

	e.indent--
	e.Line("}")
}

// generateTransforms emits JS statements that transform the value in-place before validation.
func generateTransforms(e *Emitter, accessor string, transforms []string) {
	for _, t := range transforms {
		switch t {
		case "trim":
			e.Block("if (typeof %s === \"string\")", accessor)
			e.Line("%s = %s.trim();", accessor, accessor)
			e.EndBlock()
		case "toLowerCase":
			e.Block("if (typeof %s === \"string\")", accessor)
			e.Line("%s = %s.toLowerCase();", accessor, accessor)
			e.EndBlock()
		case "toUpperCase":
			e.Block("if (typeof %s === \"string\")", accessor)
			e.Line("%s = %s.toUpperCase();", accessor, accessor)
			e.EndBlock()
		}
	}
}

// generateCoercion emits JS code to coerce string inputs to the declared type.
// This runs before type checks so "123" becomes 123 before the typeof check.
func generateCoercion(e *Emitter, accessor string, typeMeta *metadata.Metadata) {
	if typeMeta.Kind != metadata.KindAtomic {
		return
	}
	switch typeMeta.Atomic {
	case "number":
		// string → number via unary +
		e.Block("if (typeof %s === \"string\")", accessor)
		e.Line("const _n = +%s;", accessor)
		e.Block("if (!Number.isNaN(_n))")
		e.Line("%s = _n;", accessor)
		e.EndBlock()
		e.EndBlock()
	case "boolean":
		// "true"/"false" → boolean
		e.Block("if (%s === \"true\")", accessor)
		e.Line("%s = true;", accessor)
		e.EndBlockSuffix(fmt.Sprintf(" else if (%s === \"false\") {", accessor))
		e.indent++
		e.Line("%s = false;", accessor)
		e.EndBlock()
	}
	// Date coercion is handled at the type check level (KindNative "Date"),
	// not at the constraint level, so it's omitted here.
}

// generateConstraintChecks emits JS validation checks for JSDoc constraints.
// When typeVerified is true, typeof guards on constraint checks are omitted because
// the type has already been verified by a preceding type check.
func generateConstraintChecks(e *Emitter, accessor string, path string, prop *metadata.Property) {
	generateConstraintChecksInner(e, accessor, path, prop, false)
}

func generateConstraintChecksVerified(e *Emitter, accessor string, path string, prop *metadata.Property) {
	generateConstraintChecksInner(e, accessor, path, prop, true)
}

func generateConstraintChecksInner(e *Emitter, accessor string, path string, prop *metadata.Property, typeVerified bool) {
	c := prop.Constraints
	if c == nil {
		return
	}

	// Emit transforms BEFORE validation checks
	if len(c.Transforms) > 0 {
		generateTransforms(e, accessor, c.Transforms)
	}

	// Emit coercion BEFORE type checks
	if c.Coerce != nil && *c.Coerce {
		generateCoercion(e, accessor, &prop.Type)
	}

	// Helper: use per-constraint error if present, then global ErrorMessage, then default.
	// constraintKey is the Constraints field name (e.g., "format", "minLength", "minimum").
	errMsg := func(constraintKey string, defaultExpected string) string {
		if c.Errors != nil {
			if msg, ok := c.Errors[constraintKey]; ok {
				return jsStringEscape(msg)
			}
		}
		if c.ErrorMessage != nil {
			return jsStringEscape(*c.ErrorMessage)
		}
		return defaultExpected
	}

	// Numeric constraints
	if c.Minimum != nil {
		if typeVerified {
			e.Block("if (%s < %v)", accessor, *c.Minimum)
		} else {
			e.Block("if (typeof %s === \"number\" && %s < %v)", accessor, accessor, *c.Minimum)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("minimum", fmt.Sprintf("minimum %v", *c.Minimum)), accessor)
		e.EndBlock()
	}
	if c.Maximum != nil {
		if typeVerified {
			e.Block("if (%s > %v)", accessor, *c.Maximum)
		} else {
			e.Block("if (typeof %s === \"number\" && %s > %v)", accessor, accessor, *c.Maximum)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("maximum", fmt.Sprintf("maximum %v", *c.Maximum)), accessor)
		e.EndBlock()
	}
	if c.ExclusiveMinimum != nil {
		if typeVerified {
			e.Block("if (%s <= %v)", accessor, *c.ExclusiveMinimum)
		} else {
			e.Block("if (typeof %s === \"number\" && %s <= %v)", accessor, accessor, *c.ExclusiveMinimum)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("exclusiveMinimum", fmt.Sprintf("exclusiveMinimum %v", *c.ExclusiveMinimum)), accessor)
		e.EndBlock()
	}
	if c.ExclusiveMaximum != nil {
		if typeVerified {
			e.Block("if (%s >= %v)", accessor, *c.ExclusiveMaximum)
		} else {
			e.Block("if (typeof %s === \"number\" && %s >= %v)", accessor, accessor, *c.ExclusiveMaximum)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("exclusiveMaximum", fmt.Sprintf("exclusiveMaximum %v", *c.ExclusiveMaximum)), accessor)
		e.EndBlock()
	}
	if c.MultipleOf != nil {
		if typeVerified {
			e.Block("if (%s %% %v !== 0)", accessor, *c.MultipleOf)
		} else {
			e.Block("if (typeof %s === \"number\" && %s %% %v !== 0)", accessor, accessor, *c.MultipleOf)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("multipleOf", fmt.Sprintf("multipleOf %v", *c.MultipleOf)), accessor)
		e.EndBlock()
	}
	if c.NumericType != nil {
		generateNumericTypeCheck(e, accessor, path, *c.NumericType, c.ErrorMessage, c.Errors, typeVerified)
	}

	// String length constraints
	if c.MinLength != nil {
		if typeVerified {
			e.Block("if (%s.length < %d)", accessor, *c.MinLength)
		} else {
			e.Block("if (typeof %s === \"string\" && %s.length < %d)", accessor, accessor, *c.MinLength)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("minLength", fmt.Sprintf("minLength %d", *c.MinLength)), accessor)
		e.EndBlock()
	}
	if c.MaxLength != nil {
		if typeVerified {
			e.Block("if (%s.length > %d)", accessor, *c.MaxLength)
		} else {
			e.Block("if (typeof %s === \"string\" && %s.length > %d)", accessor, accessor, *c.MaxLength)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("maxLength", fmt.Sprintf("maxLength %d", *c.MaxLength)), accessor)
		e.EndBlock()
	}

	// Pattern constraint
	if c.Pattern != nil {
		if typeVerified {
			e.Block("if (!/%s/.test(%s))", *c.Pattern, accessor)
		} else {
			e.Block("if (typeof %s === \"string\" && !/%s/.test(%s))", accessor, *c.Pattern, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("pattern", fmt.Sprintf("pattern %s", *c.Pattern)), accessor)
		e.EndBlock()
	}

	// Format constraint
	if c.Format != nil {
		generateFormatCheck(e, accessor, path, *c.Format, c.ErrorMessage, c.Errors, typeVerified)
	}

	// Array constraints
	if c.MinItems != nil {
		if typeVerified {
			e.Block("if (%s.length < %d)", accessor, *c.MinItems)
		} else {
			e.Block("if (Array.isArray(%s) && %s.length < %d)", accessor, accessor, *c.MinItems)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("minItems", fmt.Sprintf("minItems %d", *c.MinItems)), accessor)
		e.EndBlock()
	}
	if c.MaxItems != nil {
		if typeVerified {
			e.Block("if (%s.length > %d)", accessor, *c.MaxItems)
		} else {
			e.Block("if (Array.isArray(%s) && %s.length > %d)", accessor, accessor, *c.MaxItems)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"length \" + %s.length });", path, errMsg("maxItems", fmt.Sprintf("maxItems %d", *c.MaxItems)), accessor)
		e.EndBlock()
	}
	if c.UniqueItems != nil && *c.UniqueItems {
		if typeVerified {
			e.Block("if (new Set(%s).size !== %s.length)", accessor, accessor)
		} else {
			e.Block("if (Array.isArray(%s) && new Set(%s).size !== %s.length)", accessor, accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"duplicate items\" });", path, errMsg("uniqueItems", "uniqueItems"))
		e.EndBlock()
	}

	// String content checks (Zod parity)
	if c.StartsWith != nil {
		escaped := jsStringEscape(*c.StartsWith)
		if typeVerified {
			e.Block("if (!%s.startsWith(\"%s\"))", accessor, escaped)
		} else {
			e.Block("if (typeof %s === \"string\" && !%s.startsWith(\"%s\"))", accessor, accessor, escaped)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("startsWith", fmt.Sprintf("startsWith %s", escaped)), accessor)
		e.EndBlock()
	}
	if c.EndsWith != nil {
		escaped := jsStringEscape(*c.EndsWith)
		if typeVerified {
			e.Block("if (!%s.endsWith(\"%s\"))", accessor, escaped)
		} else {
			e.Block("if (typeof %s === \"string\" && !%s.endsWith(\"%s\"))", accessor, accessor, escaped)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("endsWith", fmt.Sprintf("endsWith %s", escaped)), accessor)
		e.EndBlock()
	}
	if c.Includes != nil {
		escaped := jsStringEscape(*c.Includes)
		if typeVerified {
			e.Block("if (!%s.includes(\"%s\"))", accessor, escaped)
		} else {
			e.Block("if (typeof %s === \"string\" && !%s.includes(\"%s\"))", accessor, accessor, escaped)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("includes", fmt.Sprintf("includes %s", escaped)), accessor)
		e.EndBlock()
	}
	if c.Uppercase != nil && *c.Uppercase {
		if typeVerified {
			e.Block("if (%s !== %s.toUpperCase())", accessor, accessor)
		} else {
			e.Block("if (typeof %s === \"string\" && %s !== %s.toUpperCase())", accessor, accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("uppercase", "uppercase"), accessor)
		e.EndBlock()
	}
	if c.Lowercase != nil && *c.Lowercase {
		if typeVerified {
			e.Block("if (%s !== %s.toLowerCase())", accessor, accessor)
		} else {
			e.Block("if (typeof %s === \"string\" && %s !== %s.toLowerCase())", accessor, accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg("lowercase", "lowercase"), accessor)
		e.EndBlock()
	}

	// Custom validator function: Validate<typeof fn>
	if c.ValidateFn != nil {
		fnName := *c.ValidateFn
		e.Block("if (!%s(%s))", fnName, accessor)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("validate", fmt.Sprintf("validate(%s)", fnName)), accessor)
		e.EndBlock()
	}
}

// generateNumericTypeCheck emits validation for @type int32/uint32/int64/uint64/float/double.
// Checks perConstraintErrors["type"] first, then customError (global), then default.
func generateNumericTypeCheck(e *Emitter, accessor string, path string, numType string, customError *string, perConstraintErrors map[string]string, typeVerified bool) {
	errMsg := func(defaultExpected string) string {
		if perConstraintErrors != nil {
			if msg, ok := perConstraintErrors["type"]; ok {
				return jsStringEscape(msg)
			}
		}
		if customError != nil {
			return jsStringEscape(*customError)
		}
		return defaultExpected
	}
	switch numType {
	case "int32":
		if typeVerified {
			e.Block("if (!Number.isInteger(%s) || %s < -2147483648 || %s > 2147483647)", accessor, accessor, accessor)
		} else {
			e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < -2147483648 || %s > 2147483647))", accessor, accessor, accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("int32"), accessor)
		e.EndBlock()
	case "uint32":
		if typeVerified {
			e.Block("if (!Number.isInteger(%s) || %s < 0 || %s > 4294967295)", accessor, accessor, accessor)
		} else {
			e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < 0 || %s > 4294967295))", accessor, accessor, accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("uint32"), accessor)
		e.EndBlock()
	case "int64":
		if typeVerified {
			e.Block("if (!Number.isInteger(%s) || %s < -9007199254740991 || %s > 9007199254740991)", accessor, accessor, accessor)
		} else {
			e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < -9007199254740991 || %s > 9007199254740991))", accessor, accessor, accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("int64"), accessor)
		e.EndBlock()
	case "uint64":
		if typeVerified {
			e.Block("if (!Number.isInteger(%s) || %s < 0 || %s > 9007199254740991)", accessor, accessor, accessor)
		} else {
			e.Block("if (typeof %s === \"number\" && (!Number.isInteger(%s) || %s < 0 || %s > 9007199254740991))", accessor, accessor, accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("uint64"), accessor)
		e.EndBlock()
	case "float":
		if typeVerified {
			e.Block("if (!Number.isFinite(%s))", accessor)
		} else {
			e.Block("if (typeof %s === \"number\" && !Number.isFinite(%s))", accessor, accessor)
		}
		e.Line("errors.push({ path: %q, expected: \"%s\", received: \"\" + %s });", path, errMsg("float"), accessor)
		e.EndBlock()
	case "double":
		// double always passes — no extra check needed (any finite number is valid)
	}
}

// generateFormatCheck emits validation code for a string format constraint.
// Checks perConstraintErrors["format"] first, then customError (global), then default.
func generateFormatCheck(e *Emitter, accessor string, path string, format string, customError *string, perConstraintErrors map[string]string, typeVerified bool) {
	errMsg := func(defaultExpected string) string {
		if perConstraintErrors != nil {
			if msg, ok := perConstraintErrors["format"]; ok {
				return jsStringEscape(msg)
			}
		}
		if customError != nil {
			return jsStringEscape(*customError)
		}
		return defaultExpected
	}

	switch format {
	case "password":
		// No validation — any string passes
		return
	case "regex":
		// Use try/catch to validate regex
		if typeVerified {
			e.Line("try { new RegExp(%s); } catch (_e) { errors.push({ path: %q, expected: \"%s\", received: %s }); }", accessor, path, errMsg("format regex"), accessor)
		} else {
			e.Block("if (typeof %s === \"string\")", accessor)
			e.Line("try { new RegExp(%s); } catch (_e) { errors.push({ path: %q, expected: \"%s\", received: %s }); }", accessor, path, errMsg("format regex"), accessor)
			e.EndBlock()
		}
		return
	}

	// All other formats use regex validation
	pattern, ok := formatRegexes[format]
	if !ok || pattern == "" {
		return
	}

	flags := formatFlags[format]
	var regexLiteral string
	if flags != "" {
		regexLiteral = fmt.Sprintf("/%s/%s", pattern, flags)
	} else {
		regexLiteral = fmt.Sprintf("/%s/", pattern)
	}

	if typeVerified {
		e.Block("if (!%s.test(%s))", regexLiteral, accessor)
	} else {
		e.Block("if (typeof %s === \"string\" && !%s.test(%s))", accessor, regexLiteral, accessor)
	}
	e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, errMsg(fmt.Sprintf("format %s", format)), accessor)
	e.EndBlock()
}

func generateArrayCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	e.Block("if (!Array.isArray(%s))", accessor)
	e.Line("errors.push({ path: %q, expected: \"array\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	if meta.ElementType != nil {
		idx := fmt.Sprintf("i%d", depth)
		e.Block("for (let %s = 0; %s < %s.length; %s++)", idx, idx, accessor, idx)
		elemAccessor := fmt.Sprintf("%s[%s]", accessor, idx)
		elemPath := fmt.Sprintf("%s[\" + %s + \"]", path, idx)
		generateTypeCheck(e, elemAccessor, elemPath, meta.ElementType, registry, depth+1, ctx)
		e.EndBlock()
	}

	e.indent--
	e.Line("}")
}

func generateTupleCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	e.Block("if (!Array.isArray(%s))", accessor)
	e.Line("errors.push({ path: %q, expected: \"tuple\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Check required length (count non-optional, non-rest elements)
	minLen := 0
	for _, elem := range meta.Elements {
		if !elem.Optional && !elem.Rest {
			minLen++
		}
	}
	if minLen > 0 {
		e.Block("if (%s.length < %d)", accessor, minLen)
		e.Line("errors.push({ path: %q, expected: \"tuple of length >= %d\", received: %s.length });", path, minLen, accessor)
		e.EndBlock()
	}

	// Check each element
	for i, elem := range meta.Elements {
		if elem.Rest {
			continue // Rest elements are not checked individually
		}
		elemAccessor := fmt.Sprintf("%s[%d]", accessor, i)
		elemPath := fmt.Sprintf("%s[%d]", path, i)
		if elem.Optional {
			e.Block("if (%s.length > %d)", accessor, i)
			generateTypeCheck(e, elemAccessor, elemPath, &elem.Type, registry, depth+1, ctx)
			e.EndBlock()
		} else {
			generateTypeCheck(e, elemAccessor, elemPath, &elem.Type, registry, depth+1, ctx)
		}
	}

	e.indent--
	e.Line("}")
}

func generateUnionCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// For literal unions, generate a Set check
	allLiterals := true
	for _, m := range meta.UnionMembers {
		if m.Kind != metadata.KindLiteral {
			allLiterals = false
			break
		}
	}

	if allLiterals && len(meta.UnionMembers) > 0 {
		vals := make([]string, len(meta.UnionMembers))
		for i, m := range meta.UnionMembers {
			vals[i] = jsLiteral(m.LiteralValue)
		}
		setExpr := "[" + strings.Join(vals, ", ") + "]"
		e.Block("if (!%s.includes(%s))", setExpr, accessor)
		// Use jsStringEscape to safely embed literal values inside a JS string
		escapedDesc := jsStringEscape("one of " + strings.Join(vals, " | "))
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, escapedDesc, accessor)
		e.EndBlock()
		return
	}

	// Discriminated union optimization: emit switch(x[discriminantKey]) instead of try-each.
	if meta.Discriminant != nil && len(meta.Discriminant.Mapping) > 0 {
		generateDiscriminatedUnionCheck(e, accessor, path, meta, registry, depth, ctx)
		return
	}

	// For type unions, try each member — if any passes, the value is valid.
	// We use a "union check" pattern: save errors, try each branch.
	e.Line("const %s = errors.length;", unionSaveVar(depth))
	e.Line("let %s = false;", unionValidVar(depth))

	for i, member := range meta.UnionMembers {
		e.Line("// union member %d", i)
		e.Line("errors.length = %s;", unionSaveVar(depth))
		memberCopy := member
		generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth+1, ctx)
		e.Block("if (errors.length === %s)", unionSaveVar(depth))
		e.Line("%s = true;", unionValidVar(depth))
		e.EndBlock()
	}

	e.Block("if (!%s)", unionValidVar(depth))
	e.Line("errors.length = %s;", unionSaveVar(depth))
	expected := describeUnion(meta)
	e.Line("errors.push({ path: %q, expected: %q, received: typeof %s });", path, expected, accessor)
	e.EndBlock()
}

// generateDiscriminatedUnionCheck emits a switch statement on the discriminant property
// for O(1) dispatch instead of O(n) try-each for discriminated unions.
func generateDiscriminatedUnionCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	disc := meta.Discriminant
	discAccessor := fmt.Sprintf("%s[%q]", accessor, disc.Property)

	// First check the value is an object
	e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
	e.Line("errors.push({ path: %q, expected: \"object\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Build sorted list of discriminant values for deterministic output
	discValues := make([]string, 0, len(disc.Mapping))
	for v := range disc.Mapping {
		discValues = append(discValues, v)
	}
	sort.Strings(discValues)

	e.Line("switch (%s) {", discAccessor)
	e.indent++

	for _, val := range discValues {
		memberIdx := disc.Mapping[val]
		if memberIdx < 0 || memberIdx >= len(meta.UnionMembers) {
			continue
		}
		member := meta.UnionMembers[memberIdx]
		memberCopy := member

		e.Line("case %s:", jsLiteral(val))
		e.indent++
		generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth+1, ctx)
		e.Line("break;")
		e.indent--
	}

	// Default case: unknown discriminant value
	e.Line("default:")
	e.indent++
	expectedVals := make([]string, len(discValues))
	for i, v := range discValues {
		expectedVals[i] = jsLiteral(v)
	}
	expectedStr := jsStringEscape("one of " + strings.Join(expectedVals, " | "))
	e.Line("errors.push({ path: \"%s.%s\", expected: \"%s\", received: %s });", path, disc.Property, expectedStr, discAccessor)
	e.indent--

	e.indent--
	e.Line("}")

	e.EndBlock() // close else block
}

func generateEnumCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata) {
	vals := make([]string, len(meta.EnumValues))
	for i, ev := range meta.EnumValues {
		vals[i] = jsLiteral(ev.Value)
	}
	setExpr := "[" + strings.Join(vals, ", ") + "]"
	e.Block("if (!%s.includes(%s))", setExpr, accessor)
	e.Line("errors.push({ path: %q, expected: \"enum value\", received: %s });", path, accessor)
	e.EndBlock()
}

func generateNativeCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata) {
	switch meta.NativeType {
	case "Date":
		e.Block("if (!(%s instanceof Date) || isNaN(%s.getTime()))", accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"Date\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "RegExp":
		e.Block("if (!(%s instanceof RegExp))", accessor)
		e.Line("errors.push({ path: %q, expected: \"RegExp\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "Map":
		e.Block("if (!(%s instanceof Map))", accessor)
		e.Line("errors.push({ path: %q, expected: \"Map\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "Set":
		e.Block("if (!(%s instanceof Set))", accessor)
		e.Line("errors.push({ path: %q, expected: \"Set\", received: typeof %s });", path, accessor)
		e.EndBlock()
	default:
		// TypedArrays, URL, etc.
		e.Block("if (!(%s instanceof %s))", accessor, meta.NativeType)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: typeof %s });", path, meta.NativeType, accessor)
		e.EndBlock()
	}
}

// isAtomicType returns true if the base type (ignoring nullable/optional) is atomic.
// Used to determine if typeof was already checked by generateAtomicCheck.
func isAtomicType(meta *metadata.Metadata) bool {
	m := meta
	// Unwrap nullable/optional to get to the base type
	for m.Nullable || m.Optional {
		inner := *m
		inner.Nullable = false
		inner.Optional = false
		m = &inner
	}
	return m.Kind == metadata.KindAtomic
}

// --- Helpers ---

func unionSaveVar(depth int) string {
	return fmt.Sprintf("_ue%d", depth)
}

func unionValidVar(depth int) string {
	return fmt.Sprintf("_uv%d", depth)
}

func jsLiteral(v any) string {
	switch val := v.(type) {
	case string:
		return fmt.Sprintf("%q", val)
	case float64:
		return fmt.Sprintf("%v", val)
	case bool:
		if val {
			return "true"
		}
		return "false"
	default:
		return fmt.Sprintf("%v", v)
	}
}

// joinQuoted joins strings as JavaScript quoted values: "a", "b", "c"
func joinQuoted(keys []string) string {
	parts := make([]string, len(keys))
	for i, k := range keys {
		parts[i] = fmt.Sprintf("%q", k)
	}
	return strings.Join(parts, ", ")
}

// defaultToJSLiteral converts a @default string value to an appropriate JS literal.
// The type hint is used to determine parsing:
//   - string type: wraps in quotes ("hello")
//   - number type: outputs as-is (42, 3.14)
//   - boolean type: outputs true/false
//   - "null" string: outputs null
//   - otherwise: wraps in quotes as fallback
func defaultToJSLiteral(raw string, propType *metadata.Metadata) string {
	// Strip surrounding quotes from the raw value if present
	raw = stripDefaultQuotes(raw)

	// Handle explicit null
	if raw == "null" {
		return "null"
	}

	// Determine type from property metadata
	if propType != nil && propType.Kind == metadata.KindAtomic {
		switch propType.Atomic {
		case "number":
			// Validate it looks like a number, output as-is
			raw = strings.TrimSpace(raw)
			if _, err := fmt.Sscanf(raw, "%f", new(float64)); err == nil {
				return raw
			}
			return "0" // fallback for invalid number
		case "boolean":
			raw = strings.TrimSpace(strings.ToLower(raw))
			if raw == "true" {
				return "true"
			}
			return "false"
		}
	}

	// Default: treat as string
	return fmt.Sprintf("\"%s\"", jsStringEscape(raw))
}

// stripDefaultQuotes removes surrounding double or single quotes from a @default value.
func stripDefaultQuotes(s string) string {
	if len(s) >= 2 {
		if (s[0] == '"' && s[len(s)-1] == '"') || (s[0] == '\'' && s[len(s)-1] == '\'') {
			return s[1 : len(s)-1]
		}
	}
	return s
}

// jsStringEscape escapes a string so it can be safely embedded inside a
// JavaScript double-quoted string literal. It escapes double quotes and
// backslashes.
func jsStringEscape(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `"`, `\"`)
	return s
}

func describeType(meta *metadata.Metadata) string {
	switch meta.Kind {
	case metadata.KindAtomic:
		return meta.Atomic
	case metadata.KindLiteral:
		return fmt.Sprintf("%v", meta.LiteralValue)
	case metadata.KindObject:
		if meta.Name != "" {
			return meta.Name
		}
		return "object"
	case metadata.KindArray:
		return "array"
	case metadata.KindTuple:
		return "tuple"
	case metadata.KindUnion:
		return describeUnion(meta)
	case metadata.KindRef:
		return meta.Ref
	case metadata.KindNative:
		return meta.NativeType
	default:
		return string(meta.Kind)
	}
}

func describeUnion(meta *metadata.Metadata) string {
	parts := make([]string, len(meta.UnionMembers))
	for i, m := range meta.UnionMembers {
		parts[i] = describeType(&m)
	}
	return strings.Join(parts, " | ")
}

// generateStandardSchemaWrapper generates a Standard Schema v1 wrapper object
// that wraps the validate function for cross-framework interoperability.
func generateStandardSchemaWrapper(e *Emitter, typeName string) {
	schemaName := "schema" + typeName
	validateFn := "validate" + typeName
	e.Line("// Standard Schema v1 wrapper")
	e.Line("export const %s = {", schemaName)
	e.Indent()
	e.Line("\"~standard\": {")
	e.Indent()
	e.Line("version: 1,")
	e.Line("vendor: \"tsgonest\",")
	e.Block("validate(value)")
	e.Line("const result = %s(value);", validateFn)
	e.Block("if (result.success)")
	e.Line("return { value: result.data };")
	e.EndBlock()
	e.Line("return {")
	e.Indent()
	e.Line("issues: result.errors.map(e => ({")
	e.Indent()
	e.Line("message: e.message || (\"Validation failed at \" + e.path),")
	e.Line("path: e.path ? e.path.split(\".\").map(k => ({ key: k })) : []")
	e.Dedent()
	e.Line("}))")
	e.Dedent()
	e.Line("};")
	e.EndBlock() // validate(value)
	e.Dedent()
	e.Line("}")
	e.Dedent()
	e.Line("};")
}
