package codegen

import (
	"fmt"
	"sort"
	"strings"

	"github.com/tsgonest/tsgonest/internal/metadata"
)

// GenerateCompanion generates a consolidated companion file (.tsgonest.js) containing
// validation, assertion, serialization, and Standard Schema functions for a named type.
// This replaces the old separate validate.js + serialize.js files.
func GenerateCompanion(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry) string {
	return GenerateCompanionSelective(typeName, meta, registry, true, true)
}

// CompanionGenOptions holds optional feature flags for companion file generation.
type CompanionGenOptions struct {
	StandardSchema    bool   // Generate Standard Schema v1 wrappers
	ResponseTypeCheck string // "safe" (default), "guard", or "none"
}

// GenerateCompanionSelective generates a companion file with optional sections.
// includeValidation controls validate/assert functions.
// includeSerialization controls the serialize function.
// An optional CompanionGenOptions can be passed to control Standard Schema and response type check.
func GenerateCompanionSelective(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, includeValidation bool, includeSerialization bool, opts ...CompanionGenOptions) string {
	var standardSchema bool
	rtc := "safe"
	if len(opts) > 0 {
		standardSchema = opts[0].StandardSchema
		if opts[0].ResponseTypeCheck != "" {
			rtc = opts[0].ResponseTypeCheck
		}
	}
	e := NewEmitter()
	e.Line("// Auto-generated by tsgonest — do not edit")
	e.Blank()

	if includeValidation {
		// Collect and emit imports for custom validator functions (Validate<typeof fn>)
		imports := collectValidateImports(meta, registry)
		for _, imp := range imports {
			e.Line("import { %s } from %q;", imp.FnName, imp.Module)
		}
		if len(imports) > 0 {
			e.Blank()
		}
	}

	// Import helpers from shared module
	{
		var helperImports []string
		if includeValidation {
			helperImports = append(helperImports, "__e")
		}
		if includeSerialization {
			helperImports = append(helperImports, "__s", "__sa")
		}
		if len(helperImports) > 0 {
			e.Line("import { %s } from \"./_tsgonest_helpers.js\";", strings.Join(helperImports, ", "))
			e.Blank()
		}
	}

	if includeValidation {
		// Generate is function (pure boolean, zero allocations)
		isCtx := &validateCtx{
			generating: map[string]bool{typeName: true},
		}
		generateIsFunction(e, typeName, meta, registry, isCtx)
		e.Blank()

		// Generate validate function
		ctx := &validateCtx{
			generating: map[string]bool{typeName: true},
		}
		generateValidateFunction(e, typeName, meta, registry, ctx)
		e.Blank()

		// Generate assert function (standalone, throws on first error)
		assertCtx := &validateCtx{
			generating: map[string]bool{typeName: true},
		}
		generateAssertFunction(e, typeName, meta, registry, assertCtx)
		e.Blank()
	}

	if includeSerialization {
		// Generate serialize function
		sCtx := &serializeCtx{
			generating: map[string]bool{typeName: true},
		}
		generateSerializeFunction(e, typeName, meta, registry, sCtx)
		e.Blank()
	}

	if includeValidation && includeSerialization {
		// Generate stringify function (validate + serialize combined)
		generateStringifyFunction(e, typeName, rtc)
		e.Blank()
	}

	if includeValidation && standardSchema {
		// Generate Standard Schema v1 wrapper
		generateStandardSchemaWrapper(e, typeName)
	}

	return e.String()
}

// GenerateCompanionTypes generates TypeScript declaration (.tsgonest.d.ts) content
// for the consolidated companion file, including Standard Schema v1 type info.
func GenerateCompanionTypes(typeName string) string {
	return GenerateCompanionTypesSelective(typeName, true, true)
}

// GenerateCompanionTypesSelective generates type declarations with optional sections.
// Optional variadic bool controls Standard Schema generation (default: false).
func GenerateCompanionTypesSelective(typeName string, includeValidation bool, includeSerialization bool, opts ...bool) string {
	includeStandardSchema := len(opts) > 0 && opts[0]

	e := NewEmitter()
	e.Line("// Auto-generated by tsgonest — do not edit")
	e.Blank()

	if includeValidation && includeStandardSchema {
		// Define the StandardSchemaV1Props interface inline (generic for type inference)
		e.Line("interface StandardSchemaV1Props<Input = unknown, Output = Input> {")
		e.Line("  readonly version: 1;")
		e.Line("  readonly vendor: string;")
		e.Line("  readonly validate: (value: unknown) => { value: Output } | { issues: Array<{ message: string; path?: Array<{ key: string }> }> };")
		e.Line("  readonly types?: { readonly input: Input; readonly output: Output };")
		e.Line("}")
		e.Blank()
	}

	if includeValidation {
		e.Line("export declare function is%s(input: unknown): input is %s;", typeName, typeName)
		validateResult := fmt.Sprintf("{ success: true; data: %s } | { success: false; errors: Array<{ path: string; message: string }> }", typeName)
		e.Line("export declare function validate%s(input: unknown): %s;", typeName, validateResult)
		e.Line("export declare function assert%s(input: unknown): %s;", typeName, typeName)
	}

	if includeSerialization {
		e.Line("export declare function serialize%s(input: %s): string;", typeName, typeName)
	}

	if includeValidation && includeSerialization {
		e.Line("export declare function stringify%s(input: %s): string;", typeName, typeName)
	}

	if includeValidation && includeStandardSchema {
		e.Line("export declare const schema%s: { readonly \"~standard\": StandardSchemaV1Props<%s, %s> };", typeName, typeName, typeName)
	}

	return e.String()
}

// validateImport represents an import needed for a custom validator function.
type validateImport struct {
	FnName string
	Module string
}

// collectValidateImports scans the metadata tree for Validate<typeof fn> constraints
// and returns unique import entries.
func collectValidateImports(meta *metadata.Metadata, registry *metadata.TypeRegistry) []validateImport {
	seen := make(map[string]bool)
	visitedRefs := make(map[string]bool) // prevent infinite recursion on recursive types
	var imports []validateImport

	var scan func(m *metadata.Metadata)
	scan = func(m *metadata.Metadata) {
		if m == nil {
			return
		}

		switch m.Kind {
		case metadata.KindObject:
			for i := range m.Properties {
				prop := &m.Properties[i]
				if prop.Constraints != nil && prop.Constraints.ValidateFn != nil && prop.Constraints.ValidateModule != nil {
					key := *prop.Constraints.ValidateFn + "|" + *prop.Constraints.ValidateModule
					if !seen[key] {
						seen[key] = true
						imports = append(imports, validateImport{
							FnName: *prop.Constraints.ValidateFn,
							Module: toRelativeImportPath(*prop.Constraints.ValidateModule),
						})
					}
				}
				scan(&prop.Type)
			}
		case metadata.KindArray:
			if m.ElementType != nil {
				scan(m.ElementType)
			}
		case metadata.KindTuple:
			for i := range m.Elements {
				scan(&m.Elements[i].Type)
			}
		case metadata.KindUnion:
			for i := range m.UnionMembers {
				scan(&m.UnionMembers[i])
			}
		case metadata.KindRef:
			if m.Ref != "" && registry != nil && !visitedRefs[m.Ref] {
				visitedRefs[m.Ref] = true
				if resolved, ok := registry.Types[m.Ref]; ok {
					scan(resolved)
				}
			}
		}
	}

	scan(meta)

	// Sort by function name for deterministic output
	sort.Slice(imports, func(i, j int) bool {
		return imports[i].FnName < imports[j].FnName
	})

	return imports
}

// toRelativeImportPath converts a TypeScript source file path to a relative import path.
// Strips the .ts/.tsx extension and ensures it starts with "./" or "../".
func toRelativeImportPath(filePath string) string {
	// Strip .ts/.tsx/.mts/.cts extension
	for _, ext := range []string{".ts", ".tsx", ".mts", ".cts"} {
		if len(filePath) > len(ext) && filePath[len(filePath)-len(ext):] == ext {
			filePath = filePath[:len(filePath)-len(ext)]
			break
		}
	}
	// Ensure relative path prefix
	if !strings.HasPrefix(filePath, ".") && !strings.HasPrefix(filePath, "/") {
		filePath = "./" + filePath
	}
	return filePath
}

// validateCtx tracks codegen state to prevent infinite recursion on recursive types.
type validateCtx struct {
	// generating tracks type names currently being generated to detect recursion.
	generating map[string]bool
}

// generateValidateFunction generates: export function validate<Name>(input) { ... }
// For recursive types, generates an inner function with path+errors parameters
// to avoid expensive regex path rewrites and spread operations.
func generateValidateFunction(e *Emitter, typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, ctx *validateCtx) {
	fnName := "validate" + typeName

	// Check if the type is recursive — if so, use inner function pattern
	isRecursive := isRecursiveType(typeName, meta, registry)

	if isRecursive {
		// Generate inner function that takes path and errors parameters
		innerFn := "_validate" + typeName
		e.Block("function %s(input, _path, errors)", innerFn)
		generateTypeCheckWithPath(e, "input", "_path", meta, registry, 0, ctx)
		e.EndBlock()
		e.Block("export function %s(input)", fnName)
		e.Line("const errors = [];")
		e.Line("%s(input, \"input\", errors);", innerFn)
		e.Block("if (errors.length > 0)")
		e.Line("return { success: false, errors };")
		e.EndBlock()
		e.Line("return { success: true, data: input };")
		e.EndBlock()
	} else {
		e.Block("export function %s(input)", fnName)
		e.Line("const errors = [];")
		generateTypeCheck(e, "input", "", meta, registry, 0, ctx)
		e.Block("if (errors.length > 0)")
		e.Line("return { success: false, errors };")
		e.EndBlock()
		e.Line("return { success: true, data: input };")
		e.EndBlock()
	}
}

// generateTypeCheckWithPath generates validation checks using a dynamic path variable
// instead of hardcoded path strings. Used for recursive type validation.
func generateTypeCheckWithPath(e *Emitter, accessor string, pathExpr string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// Handle nullable/optional
	if meta.Nullable && meta.Optional {
		e.Block("if (%s !== null && %s !== undefined)", accessor, accessor)
		generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Nullable {
		e.Block("if (%s !== null)", accessor)
		generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Optional {
		e.Block("if (%s !== undefined)", accessor)
		generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	generateTypeCheckWithPathInner(e, accessor, pathExpr, meta, registry, depth, ctx)
}

func generateTypeCheckWithPathInner(e *Emitter, accessor string, pathExpr string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	switch meta.Kind {
	case metadata.KindAtomic:
		switch meta.Atomic {
		case "string":
			e.Block("if (typeof %s !== \"string\")", accessor)
			e.Line("errors.push({ path: %s, expected: \"string\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		case "number":
			e.Block("if (typeof %s !== \"number\" || !Number.isFinite(%s))", accessor, accessor)
			e.Line("errors.push({ path: %s, expected: \"number\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		case "boolean":
			e.Block("if (typeof %s !== \"boolean\")", accessor)
			e.Line("errors.push({ path: %s, expected: \"boolean\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		case "bigint":
			e.Block("if (typeof %s !== \"bigint\")", accessor)
			e.Line("errors.push({ path: %s, expected: \"bigint\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		}

	case metadata.KindObject:
		e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
		e.Line("errors.push({ path: %s, expected: \"object\", received: typeof %s });", pathExpr, accessor)
		e.EndBlockSuffix(" else {")
		e.indent++
		for _, prop := range meta.Properties {
			propAccessor := jsPropAccess(accessor, prop.Name)
			propPathExpr := fmt.Sprintf("%s + %q", pathExpr, jsPropPathSuffix(prop.Name))
			if prop.Required && !prop.Type.Optional {
				e.Block("if (%s === undefined)", propAccessor)
				e.Line("errors.push({ path: %s, expected: \"%s\", received: \"undefined\" });", propPathExpr, describeType(&prop.Type))
				e.EndBlockSuffix(" else {")
				e.indent++
				generateTypeCheckWithPath(e, propAccessor, propPathExpr, &prop.Type, registry, depth+1, ctx)
				e.indent--
				e.Line("}")
			} else {
				generateTypeCheckWithPath(e, propAccessor, propPathExpr, &prop.Type, registry, depth+1, ctx)
			}
		}
		e.indent--
		e.Line("}")

	case metadata.KindArray:
		e.Block("if (!Array.isArray(%s))", accessor)
		e.Line("errors.push({ path: %s, expected: \"array\", received: typeof %s });", pathExpr, accessor)
		e.EndBlockSuffix(" else {")
		e.indent++
		if meta.ElementType != nil {
			idx := fmt.Sprintf("i%d", depth)
			e.Block("for (let %s = 0; %s < %s.length; %s++)", idx, idx, accessor, idx)
			elemAccessor := fmt.Sprintf("%s[%s]", accessor, idx)
			elemPathExpr := fmt.Sprintf("%s + \"[\" + %s + \"]\"", pathExpr, idx)
			generateTypeCheckWithPath(e, elemAccessor, elemPathExpr, meta.ElementType, registry, depth+1, ctx)
			e.EndBlock()
		}
		e.indent--
		e.Line("}")

	case metadata.KindRef:
		if ctx != nil && ctx.generating[meta.Ref] {
			// Recursive call — use inner function with shared errors array
			innerFn := "_validate" + meta.Ref
			e.Line("%s(%s, %s, errors);", innerFn, accessor, pathExpr)
		} else if resolved, ok := registry.Types[meta.Ref]; ok {
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			generateTypeCheckWithPath(e, accessor, pathExpr, resolved, registry, depth, ctx)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
		}

	case metadata.KindEnum:
		if len(meta.EnumValues) > 0 {
			vals := make([]string, len(meta.EnumValues))
			for i, ev := range meta.EnumValues {
				vals[i] = jsLiteral(ev.Value)
			}
			setExpr := "[" + strings.Join(vals, ", ") + "]"
			e.Block("if (!%s.includes(%s))", setExpr, accessor)
			e.Line("errors.push({ path: %s, expected: \"enum value\", received: %s });", pathExpr, accessor)
			e.EndBlock()
		}

	case metadata.KindNative:
		switch meta.NativeType {
		case "Date":
			e.Block("if (!(%s instanceof Date) || isNaN(%s.getTime()))", accessor, accessor)
			e.Line("errors.push({ path: %s, expected: \"Date\", received: typeof %s });", pathExpr, accessor)
			e.EndBlock()
		default:
			e.Block("if (!(%s instanceof %s))", accessor, meta.NativeType)
			e.Line("errors.push({ path: %s, expected: \"%s\", received: typeof %s });", pathExpr, meta.NativeType, accessor)
			e.EndBlock()
		}

	case metadata.KindUnion:
		// For recursive validate with path, use the same union pattern but with dynamic path
		// Delegate to the standard generateTypeCheck since unions are complex
		// and the path rewrite is mainly an issue for recursive refs, not unions
		generateUnionCheck(e, accessor, pathExpr, meta, registry, depth, ctx)

	case metadata.KindLiteral:
		e.Block("if (%s !== %s)", accessor, jsLiteral(meta.LiteralValue))
		e.Line("errors.push({ path: %s, expected: %q, received: %s });", pathExpr, fmt.Sprintf("%v", meta.LiteralValue), accessor)
		e.EndBlock()

	case metadata.KindAny, metadata.KindUnknown:
		// No validation

	case metadata.KindNever:
		e.Line("errors.push({ path: %s, expected: \"never\", received: typeof %s });", pathExpr, accessor)

	case metadata.KindVoid:
		e.Block("if (%s !== undefined)", accessor)
		e.Line("errors.push({ path: %s, expected: \"void\", received: typeof %s });", pathExpr, accessor)
		e.EndBlock()

	case metadata.KindIntersection:
		for _, member := range meta.IntersectionMembers {
			memberCopy := member
			generateTypeCheckWithPathInner(e, accessor, pathExpr, &memberCopy, registry, depth, ctx)
		}
	}
}

// isRecursiveType checks if a type contains a recursive reference to itself.
func isRecursiveType(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry) bool {
	visited := map[string]bool{typeName: true}
	return hasRecursiveRef(meta, registry, visited, typeName)
}

func hasRecursiveRef(meta *metadata.Metadata, registry *metadata.TypeRegistry, visited map[string]bool, target string) bool {
	if meta == nil {
		return false
	}
	switch meta.Kind {
	case metadata.KindRef:
		if meta.Ref == target {
			return true
		}
		if visited[meta.Ref] {
			return false
		}
		visited[meta.Ref] = true
		if resolved, ok := registry.Types[meta.Ref]; ok {
			return hasRecursiveRef(resolved, registry, visited, target)
		}
	case metadata.KindObject:
		for i := range meta.Properties {
			if hasRecursiveRef(&meta.Properties[i].Type, registry, visited, target) {
				return true
			}
		}
	case metadata.KindArray:
		return hasRecursiveRef(meta.ElementType, registry, visited, target)
	case metadata.KindTuple:
		for i := range meta.Elements {
			if hasRecursiveRef(&meta.Elements[i].Type, registry, visited, target) {
				return true
			}
		}
	case metadata.KindUnion:
		for i := range meta.UnionMembers {
			if hasRecursiveRef(&meta.UnionMembers[i], registry, visited, target) {
				return true
			}
		}
	case metadata.KindIntersection:
		for i := range meta.IntersectionMembers {
			if hasRecursiveRef(&meta.IntersectionMembers[i], registry, visited, target) {
				return true
			}
		}
	}
	return false
}

// generateStringifyFunction generates a combined validate+serialize function.
// mode controls the type checking behavior:
//   - "safe" (default): full validation with detailed errors before serializing
//   - "guard": lightweight boolean type guard check before serializing
//   - "none": no runtime check, serialize directly (maximum performance)
func generateStringifyFunction(e *Emitter, typeName string, mode string) {
	fnName := "stringify" + typeName
	serializeFn := "serialize" + typeName
	e.Block("export function %s(input)", fnName)

	switch mode {
	case "guard":
		// Lightweight boolean check — zero allocations on the happy path
		isFn := "is" + typeName
		e.Block("if (!%s(input))", isFn)
		e.Line("throw new TypeError(\"Serialization type check failed for %s\");", typeName)
		e.EndBlock()
		e.Line("return %s(input);", serializeFn)
	case "none":
		// No runtime check — trust the application layer
		e.Line("return %s(input);", serializeFn)
	default: // "safe"
		// Full validation with detailed error reporting
		validateFn := "validate" + typeName
		e.Line("const r = %s(input);", validateFn)
		e.Block("if (!r.success)")
		e.Line("const e = new TypeError(\"Serialization type check failed for %s\");", typeName)
		e.Line("e.errors = r.errors;")
		e.Line("throw e;")
		e.EndBlock()
		e.Line("return %s(input);", serializeFn)
	}

	e.EndBlock()
}

// generateTypeCheck generates validation checks for a type at the given access path.
// `accessor` is the JS expression to access the value (e.g., "input", "input.name").
// `path` is the error path string (e.g., "input.name").
func generateTypeCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	if path == "" {
		path = accessor
	}

	// Handle nullable
	if meta.Nullable && meta.Optional {
		e.Block("if (%s !== null && %s !== undefined)", accessor, accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Nullable {
		e.Block("if (%s !== null)", accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}
	if meta.Optional {
		e.Block("if (%s !== undefined)", accessor)
		generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
		e.EndBlock()
		return
	}

	generateTypeCheckInner(e, accessor, path, meta, registry, depth, ctx)
}

// generateTypeCheckInner generates the actual type checks (after null/undefined handling).
func generateTypeCheckInner(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	switch meta.Kind {
	case metadata.KindAtomic:
		generateAtomicCheck(e, accessor, path, meta.Atomic)
		// Template literal types produce a regex pattern — validate it at runtime
		if meta.Atomic == "string" && meta.TemplatePattern != "" {
			e.Block("if (typeof %s === \"string\" && !/%s/.test(%s))", accessor, escapeForRegexLiteral(meta.TemplatePattern), accessor)
			e.Line("errors.push({ path: %q, expected: \"pattern %s\", received: %s });", path, jsStringEscape(meta.TemplatePattern), accessor)
			e.EndBlock()
		}

	case metadata.KindLiteral:
		generateLiteralCheck(e, accessor, path, meta.LiteralValue)

	case metadata.KindObject:
		generateObjectCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindArray:
		generateArrayCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindTuple:
		generateTupleCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindUnion:
		generateUnionCheck(e, accessor, path, meta, registry, depth, ctx)

	case metadata.KindRef:
		// For recursive references (type currently being generated),
		// emit a recursive function call instead of inlining to prevent
		// infinite recursion during codegen.
		if ctx != nil && ctx.generating[meta.Ref] {
			// Emit a recursive call to the validate function being generated
			fnName := "validate" + meta.Ref
			e.Line("{ const _r = %s(%s); if (!_r.success) errors.push(..._r.errors.map(e => ({ ...e, path: e.path.replace(/^input/, %q) }))); }", fnName, accessor, path)
		} else if resolved, ok := registry.Types[meta.Ref]; ok {
			// Non-recursive ref: inline the checks as before
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			generateTypeCheck(e, accessor, path, resolved, registry, depth, ctx)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
		}

	case metadata.KindEnum:
		// Enum types are handled as unions of their literal values
		if len(meta.EnumValues) > 0 {
			generateEnumCheck(e, accessor, path, meta)
		}

	case metadata.KindNative:
		generateNativeCheck(e, accessor, path, meta)

	case metadata.KindAny, metadata.KindUnknown:
		// No validation for any/unknown

	case metadata.KindNever:
		e.Line("errors.push({ path: %q, expected: \"never\", received: typeof %s });", path, accessor)

	case metadata.KindVoid:
		e.Block("if (%s !== undefined)", accessor)
		e.Line("errors.push({ path: %q, expected: \"void\", received: typeof %s });", path, accessor)
		e.EndBlock()

	case metadata.KindIntersection:
		// Intersection: all members must pass validation
		for _, member := range meta.IntersectionMembers {
			memberCopy := member
			generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth, ctx)
		}
	}
}

func generateAtomicCheck(e *Emitter, accessor string, path string, atomic string) {
	switch atomic {
	case "string":
		e.Block("if (typeof %s !== \"string\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"string\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "number":
		e.Block("if (typeof %s !== \"number\" || !Number.isFinite(%s))", accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"number\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "boolean":
		e.Block("if (typeof %s !== \"boolean\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"boolean\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "bigint":
		e.Block("if (typeof %s !== \"bigint\")", accessor)
		e.Line("errors.push({ path: %q, expected: \"bigint\", received: typeof %s });", path, accessor)
		e.EndBlock()
	}
}

func generateLiteralCheck(e *Emitter, accessor string, path string, value any) {
	switch v := value.(type) {
	case string:
		e.Block("if (%s !== %q)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %q, received: %s });", path, v, accessor)
		e.EndBlock()
	case float64:
		e.Block("if (%s !== %v)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %v, received: %s });", path, v, accessor)
		e.EndBlock()
	case bool:
		e.Block("if (%s !== %v)", accessor, v)
		e.Line("errors.push({ path: %q, expected: %v, received: %s });", path, v, accessor)
		e.EndBlock()
	}
}

func generateObjectCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// Check it's an object
	e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
	e.Line("errors.push({ path: %q, expected: \"object\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Handle object strictness
	if meta.Strictness == "strict" || meta.Strictness == "strip" {
		// Build known keys set
		knownKeys := make([]string, 0, len(meta.Properties))
		for _, prop := range meta.Properties {
			knownKeys = append(knownKeys, prop.Name)
		}
		knownSetExpr := "new Set([" + joinQuoted(knownKeys) + "])"

		if meta.Strictness == "strict" {
			// Strict: reject unknown properties
			kVar := fmt.Sprintf("_k%d", depth)
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
			e.Line("errors.push({ path: %q + \".\" + %s, expected: \"known property\", received: %s });", path, kVar, kVar)
			e.EndBlock()
			e.EndBlock()
		} else if meta.Strictness == "strip" {
			// Strip: remove unknown properties
			kVar := fmt.Sprintf("_k%d", depth)
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
			e.Line("delete %s[%s];", accessor, kVar)
			e.EndBlock()
			e.EndBlock()
		}
	}

	// Check each property
	for _, prop := range meta.Properties {
		propAccessor := jsPropAccess(accessor, prop.Name)
		propPath := path + jsPropPathSuffix(prop.Name)

		// Emit default value assignment BEFORE validation.
		// When a property has @default and the value is undefined, fill it in.
		if prop.Constraints != nil && prop.Constraints.Default != nil {
			jsDefault := defaultToJSLiteral(*prop.Constraints.Default, &prop.Type)
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("%s = %s;", propAccessor, jsDefault)
			e.EndBlock()
		}

		if prop.Required && !prop.Type.Optional {
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("errors.push({ path: %q, expected: \"%s\", received: \"undefined\" });", propPath, describeType(&prop.Type))
			e.EndBlockSuffix(" else {")
			e.indent++
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			// After type check, emit constraint checks.
			// When the base type is atomic, the typeof check was already done
			// by generateAtomicCheck, so constraints can skip the typeof guard.
			if prop.Constraints != nil {
				if isAtomicType(&prop.Type) {
					generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
				} else {
					generateConstraintChecks(e, propAccessor, propPath, &prop)
				}
			}
			e.indent--
			e.Line("}")
		} else if prop.ExactOptional {
			// exactOptionalPropertyTypes: property can be missing but not explicitly undefined
			e.Block("if (%q in %s)", prop.Name, accessor)
			e.Block("if (%s === undefined)", propAccessor)
			e.Line("errors.push({ path: %q, expected: \"%s (not undefined)\", received: \"undefined\" });", propPath, describeType(&prop.Type))
			e.EndBlockSuffix(" else {")
			e.indent++
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			if prop.Constraints != nil {
				if isAtomicType(&prop.Type) {
					generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
				} else {
					generateConstraintChecks(e, propAccessor, propPath, &prop)
				}
			}
			e.indent--
			e.Line("}")
			e.EndBlock()
		} else {
			generateTypeCheck(e, propAccessor, propPath, &prop.Type, registry, depth+1, ctx)
			// After type check, emit constraint checks (only if value is present)
			if prop.Constraints != nil {
				if prop.Type.Optional || !prop.Required {
					e.Block("if (%s !== undefined)", propAccessor)
					if isAtomicType(&prop.Type) {
						generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
					} else {
						generateConstraintChecks(e, propAccessor, propPath, &prop)
					}
					e.EndBlock()
				} else {
					if isAtomicType(&prop.Type) {
						generateConstraintChecksVerified(e, propAccessor, propPath, &prop)
					} else {
						generateConstraintChecks(e, propAccessor, propPath, &prop)
					}
				}
			}
		}
	}

	// Index signature validation: for objects with [key: string]: T,
	// validate that all keys not in the declared properties have values matching T.
	if meta.IndexSignature != nil {
		kVar := fmt.Sprintf("_ik%d", depth)
		// Build set of known property names to exclude
		if len(meta.Properties) > 0 {
			knownKeys := make([]string, 0, len(meta.Properties))
			for _, prop := range meta.Properties {
				knownKeys = append(knownKeys, prop.Name)
			}
			knownSetExpr := "new Set([" + joinQuoted(knownKeys) + "])"
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
			e.Block("if (!%s.has(%s))", knownSetExpr, kVar)
		} else {
			e.Block("for (const %s of Object.keys(%s))", kVar, accessor)
		}

		elemAccessor := fmt.Sprintf("%s[%s]", accessor, kVar)
		elemPath := fmt.Sprintf("%s[\" + %s + \"]", path, kVar)
		generateTypeCheck(e, elemAccessor, elemPath, &meta.IndexSignature.ValueType, registry, depth+1, ctx)

		if len(meta.Properties) > 0 {
			e.EndBlock() // close the if (!knownSet.has) block
		}
		e.EndBlock() // close the for loop
	}

	e.indent--
	e.Line("}")
}

func generateArrayCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	e.Block("if (!Array.isArray(%s))", accessor)
	e.Line("errors.push({ path: %q, expected: \"array\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	if meta.ElementType != nil {
		idx := fmt.Sprintf("i%d", depth)
		e.Block("for (let %s = 0; %s < %s.length; %s++)", idx, idx, accessor, idx)
		elemAccessor := fmt.Sprintf("%s[%s]", accessor, idx)
		elemPath := fmt.Sprintf("%s[\" + %s + \"]", path, idx)
		generateTypeCheck(e, elemAccessor, elemPath, meta.ElementType, registry, depth+1, ctx)
		e.EndBlock()
	}

	e.indent--
	e.Line("}")
}

func generateTupleCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	e.Block("if (!Array.isArray(%s))", accessor)
	e.Line("errors.push({ path: %q, expected: \"tuple\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Check required length (count non-optional, non-rest elements)
	minLen := 0
	for _, elem := range meta.Elements {
		if !elem.Optional && !elem.Rest {
			minLen++
		}
	}
	if minLen > 0 {
		e.Block("if (%s.length < %d)", accessor, minLen)
		e.Line("errors.push({ path: %q, expected: \"tuple of length >= %d\", received: %s.length });", path, minLen, accessor)
		e.EndBlock()
	}

	// Check each element
	for i, elem := range meta.Elements {
		if elem.Rest {
			continue // Rest elements are not checked individually
		}
		elemAccessor := fmt.Sprintf("%s[%d]", accessor, i)
		elemPath := fmt.Sprintf("%s[%d]", path, i)
		if elem.Optional {
			e.Block("if (%s.length > %d)", accessor, i)
			generateTypeCheck(e, elemAccessor, elemPath, &elem.Type, registry, depth+1, ctx)
			e.EndBlock()
		} else {
			generateTypeCheck(e, elemAccessor, elemPath, &elem.Type, registry, depth+1, ctx)
		}
	}

	e.indent--
	e.Line("}")
}

func generateUnionCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	// For literal unions, generate a Set check
	allLiterals := true
	for _, m := range meta.UnionMembers {
		if m.Kind != metadata.KindLiteral {
			allLiterals = false
			break
		}
	}

	if allLiterals && len(meta.UnionMembers) > 0 {
		vals := make([]string, len(meta.UnionMembers))
		for i, m := range meta.UnionMembers {
			vals[i] = jsLiteral(m.LiteralValue)
		}
		setExpr := "[" + strings.Join(vals, ", ") + "]"
		e.Block("if (!%s.includes(%s))", setExpr, accessor)
		// Use jsStringEscape to safely embed literal values inside a JS string
		escapedDesc := jsStringEscape("one of " + strings.Join(vals, " | "))
		e.Line("errors.push({ path: %q, expected: \"%s\", received: %s });", path, escapedDesc, accessor)
		e.EndBlock()
		return
	}

	// Discriminated union optimization: emit switch(x[discriminantKey]) instead of try-each.
	if meta.Discriminant != nil && len(meta.Discriminant.Mapping) > 0 {
		generateDiscriminatedUnionCheck(e, accessor, path, meta, registry, depth, ctx)
		return
	}

	// For type unions, try each member — if any passes, the value is valid.
	// We use a "union check" pattern: save errors, try each branch.
	e.Line("const %s = errors.length;", unionSaveVar(depth))
	e.Line("let %s = false;", unionValidVar(depth))

	for i, member := range meta.UnionMembers {
		e.Line("// union member %d", i)
		e.Line("errors.length = %s;", unionSaveVar(depth))
		memberCopy := member
		generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth+1, ctx)
		e.Block("if (errors.length === %s)", unionSaveVar(depth))
		e.Line("%s = true;", unionValidVar(depth))
		e.EndBlock()
	}

	e.Block("if (!%s)", unionValidVar(depth))
	e.Line("errors.length = %s;", unionSaveVar(depth))
	expected := describeUnion(meta)
	e.Line("errors.push({ path: %q, expected: %q, received: typeof %s });", path, expected, accessor)
	e.EndBlock()
}

// generateDiscriminatedUnionCheck emits a switch statement on the discriminant property
// for O(1) dispatch instead of O(n) try-each for discriminated unions.
func generateDiscriminatedUnionCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *validateCtx) {
	disc := meta.Discriminant
	discAccessor := jsPropAccess(accessor, disc.Property)

	// First check the value is an object
	e.Block("if (typeof %s !== \"object\" || %s === null)", accessor, accessor)
	e.Line("errors.push({ path: %q, expected: \"object\", received: typeof %s });", path, accessor)
	e.EndBlockSuffix(" else {")
	e.indent++

	// Build sorted list of discriminant values for deterministic output
	discValues := make([]string, 0, len(disc.Mapping))
	for v := range disc.Mapping {
		discValues = append(discValues, v)
	}
	sort.Strings(discValues)

	e.Line("switch (%s) {", discAccessor)
	e.indent++

	for _, val := range discValues {
		memberIdx := disc.Mapping[val]
		if memberIdx < 0 || memberIdx >= len(meta.UnionMembers) {
			continue
		}
		member := meta.UnionMembers[memberIdx]
		memberCopy := member

		e.Line("case %s:", jsLiteral(val))
		e.indent++
		generateTypeCheckInner(e, accessor, path, &memberCopy, registry, depth+1, ctx)
		e.Line("break;")
		e.indent--
	}

	// Default case: unknown discriminant value
	e.Line("default:")
	e.indent++
	expectedVals := make([]string, len(discValues))
	for i, v := range discValues {
		expectedVals[i] = jsLiteral(v)
	}
	expectedStr := jsStringEscape("one of " + strings.Join(expectedVals, " | "))
	e.Line("errors.push({ path: \"%s%s\", expected: \"%s\", received: %s });", path, jsStringEscape(jsPropPathSuffix(disc.Property)), expectedStr, discAccessor)
	e.indent--

	e.indent--
	e.Line("}")

	e.EndBlock() // close else block
}

func generateEnumCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata) {
	vals := make([]string, len(meta.EnumValues))
	for i, ev := range meta.EnumValues {
		vals[i] = jsLiteral(ev.Value)
	}
	setExpr := "[" + strings.Join(vals, ", ") + "]"
	e.Block("if (!%s.includes(%s))", setExpr, accessor)
	e.Line("errors.push({ path: %q, expected: \"enum value\", received: %s });", path, accessor)
	e.EndBlock()
}

func generateNativeCheck(e *Emitter, accessor string, path string, meta *metadata.Metadata) {
	switch meta.NativeType {
	case "Date":
		e.Block("if (!(%s instanceof Date) || isNaN(%s.getTime()))", accessor, accessor)
		e.Line("errors.push({ path: %q, expected: \"Date\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "RegExp":
		e.Block("if (!(%s instanceof RegExp))", accessor)
		e.Line("errors.push({ path: %q, expected: \"RegExp\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "Map":
		e.Block("if (!(%s instanceof Map))", accessor)
		e.Line("errors.push({ path: %q, expected: \"Map\", received: typeof %s });", path, accessor)
		e.EndBlock()
	case "Set":
		e.Block("if (!(%s instanceof Set))", accessor)
		e.Line("errors.push({ path: %q, expected: \"Set\", received: typeof %s });", path, accessor)
		e.EndBlock()
	default:
		// TypedArrays, URL, etc.
		e.Block("if (!(%s instanceof %s))", accessor, meta.NativeType)
		e.Line("errors.push({ path: %q, expected: \"%s\", received: typeof %s });", path, meta.NativeType, accessor)
		e.EndBlock()
	}
}

// isAtomicType returns true if the base type (ignoring nullable/optional) is atomic.
// Used to determine if typeof was already checked by generateAtomicCheck.
func isAtomicType(meta *metadata.Metadata) bool {
	m := meta
	// Unwrap nullable/optional to get to the base type
	for m.Nullable || m.Optional {
		inner := *m
		inner.Nullable = false
		inner.Optional = false
		m = &inner
	}
	return m.Kind == metadata.KindAtomic
}
