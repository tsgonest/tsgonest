package codegen

import (
	"fmt"
	"strings"

	"github.com/tsgonest/tsgonest/internal/metadata"
)

// serializeCtx tracks codegen state to prevent infinite recursion on recursive types.
type serializeCtx struct {
	// generating tracks type names currently being generated to detect recursion.
	generating map[string]bool
}

// GenerateSerialization generates a fast JSON serialization function for a named type.
func GenerateSerialization(typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry) string {
	e := NewEmitter()
	e.Line("// Auto-generated by tsgonest â€” do not edit")
	e.Blank()

	// Helper for string escaping
	e.Block("function __jsonStr(s)")
	e.Line("return JSON.stringify(s);")
	e.EndBlock()
	e.Blank()

	ctx := &serializeCtx{
		generating: map[string]bool{typeName: true},
	}
	generateSerializeFunction(e, typeName, meta, registry, ctx)

	return e.String()
}

// generateSerializeFunction generates: export function serialize<Name>(input) { ... }
func generateSerializeFunction(e *Emitter, typeName string, meta *metadata.Metadata, registry *metadata.TypeRegistry, ctx *serializeCtx) {
	fnName := "serialize" + typeName
	e.Block("export function %s(input)", fnName)
	e.Line("return %s;", generateSerializeExpr("input", meta, registry, 0, ctx))
	e.EndBlock()
}

// generateSerializeExpr returns a JS expression that serializes the value at `accessor`.
func generateSerializeExpr(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *serializeCtx) string {
	// Handle nullable/optional wrapping
	if meta.Nullable || meta.Optional {
		inner := *meta
		inner.Nullable = false
		inner.Optional = false
		nullCheck := accessor + " == null"
		return fmt.Sprintf("(%s ? \"null\" : %s)", nullCheck, generateSerializeExpr(accessor, &inner, registry, depth, ctx))
	}

	switch meta.Kind {
	case metadata.KindAtomic:
		return generateSerializeAtomic(accessor, meta.Atomic)

	case metadata.KindLiteral:
		return generateSerializeLiteral(meta.LiteralValue)

	case metadata.KindObject:
		return generateSerializeObject(accessor, meta, registry, depth, ctx)

	case metadata.KindArray:
		return generateSerializeArray(accessor, meta, registry, depth, ctx)

	case metadata.KindTuple:
		return generateSerializeTuple(accessor, meta, registry, depth, ctx)

	case metadata.KindUnion:
		// For unions, fall back to JSON.stringify
		return fmt.Sprintf("JSON.stringify(%s)", accessor)

	case metadata.KindRef:
		// For recursive references, emit a function call to prevent infinite codegen recursion
		if ctx != nil && ctx.generating[meta.Ref] {
			fnName := "serialize" + meta.Ref
			return fmt.Sprintf("%s(%s)", fnName, accessor)
		}
		if resolved, ok := registry.Types[meta.Ref]; ok {
			if ctx != nil {
				ctx.generating[meta.Ref] = true
			}
			result := generateSerializeExpr(accessor, resolved, registry, depth, ctx)
			if ctx != nil {
				delete(ctx.generating, meta.Ref)
			}
			return result
		}
		return fmt.Sprintf("JSON.stringify(%s)", accessor)

	case metadata.KindNative:
		return generateSerializeNative(accessor, meta)

	case metadata.KindEnum:
		return fmt.Sprintf("JSON.stringify(%s)", accessor)

	default:
		return fmt.Sprintf("JSON.stringify(%s)", accessor)
	}
}

func generateSerializeAtomic(accessor string, atomic string) string {
	switch atomic {
	case "string":
		return fmt.Sprintf("__jsonStr(%s)", accessor)
	case "number", "bigint":
		return fmt.Sprintf("\"\" + %s", accessor)
	case "boolean":
		return fmt.Sprintf("(%s ? \"true\" : \"false\")", accessor)
	default:
		return fmt.Sprintf("JSON.stringify(%s)", accessor)
	}
}

func generateSerializeLiteral(value any) string {
	switch v := value.(type) {
	case string:
		return fmt.Sprintf("%q", fmt.Sprintf("%q", v)) // pre-encoded
	case float64:
		return fmt.Sprintf("\"%v\"", v)
	case bool:
		if v {
			return "\"true\""
		}
		return "\"false\""
	default:
		return fmt.Sprintf("\"%v\"", v)
	}
}

func generateSerializeObject(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *serializeCtx) string {
	if len(meta.Properties) == 0 {
		return fmt.Sprintf("JSON.stringify(%s)", accessor)
	}

	// Check if any property is optional
	hasOptional := false
	for _, prop := range meta.Properties {
		if prop.Type.Optional || !prop.Required {
			hasOptional = true
			break
		}
	}

	// If all properties are required, use the fast inline concatenation approach
	if !hasOptional {
		return generateSerializeObjectAllRequired(accessor, meta, registry, depth, ctx)
	}

	// For objects with optional properties, use a parts-based approach
	// that conditionally includes keys
	return generateSerializeObjectWithOptional(accessor, meta, registry, depth, ctx)
}

// generateSerializeObjectAllRequired generates fast inline string concatenation
// for objects where all properties are required (no conditional key inclusion needed).
func generateSerializeObjectAllRequired(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *serializeCtx) string {
	var parts []string
	parts = append(parts, `"{"`)

	for i, prop := range meta.Properties {
		propAccessor := accessor + "." + prop.Name

		sep := ""
		if i > 0 {
			sep = ","
		}
		// Build the key as a JS string literal: ',"name":'
		keyJS := fmt.Sprintf(`"%s\"%s\":"`, sep, prop.Name)
		valExpr := generateSerializeExpr(propAccessor, &prop.Type, registry, depth+1, ctx)
		parts = append(parts, keyJS+" + "+valExpr)
	}

	parts = append(parts, `"}"`)
	return strings.Join(parts, " + ")
}

// generateSerializeObjectWithOptional generates serialization using a __serObj helper
// that conditionally includes optional keys. This avoids the JSON.stringify fallback.
func generateSerializeObjectWithOptional(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *serializeCtx) string {
	// Use an IIFE that builds up parts array with conditional inclusion
	partsVar := fmt.Sprintf("_p%d", depth)

	var lines []string
	lines = append(lines, fmt.Sprintf("(function() { var %s = [];", partsVar))

	for _, prop := range meta.Properties {
		propAccessor := accessor + "." + prop.Name
		valExpr := generateSerializeExpr(propAccessor, &prop.Type, registry, depth+1, ctx)
		keyExpr := fmt.Sprintf(`"\"%s\":" + %s`, prop.Name, valExpr)

		if prop.Type.Optional || !prop.Required {
			lines = append(lines, fmt.Sprintf("if (%s !== undefined) %s.push(%s);", propAccessor, partsVar, keyExpr))
		} else {
			lines = append(lines, fmt.Sprintf("%s.push(%s);", partsVar, keyExpr))
		}
	}

	lines = append(lines, fmt.Sprintf("return \"{\" + %s.join(\",\") + \"}\"; })()", partsVar))
	return strings.Join(lines, " ")
}

func generateSerializeArray(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *serializeCtx) string {
	if meta.ElementType == nil {
		return fmt.Sprintf("JSON.stringify(%s)", accessor)
	}

	idx := fmt.Sprintf("_i%d", depth)
	elemAccessor := fmt.Sprintf("%s[%s]", accessor, idx)
	elemExpr := generateSerializeExpr(elemAccessor, meta.ElementType, registry, depth+1, ctx)

	return fmt.Sprintf("\"[\" + %s.map(function(%s, %s) { return %s; }).join(\",\") + \"]\"",
		accessor, fmt.Sprintf("_v%d", depth), idx, elemExpr)
}

func generateSerializeTuple(accessor string, meta *metadata.Metadata, registry *metadata.TypeRegistry, depth int, ctx *serializeCtx) string {
	if len(meta.Elements) == 0 {
		return "\"[]\""
	}

	var parts []string
	parts = append(parts, "\"[\"")

	for i, elem := range meta.Elements {
		if i > 0 {
			parts = append(parts, "\",\"")
		}
		elemAccessor := fmt.Sprintf("%s[%d]", accessor, i)
		parts = append(parts, generateSerializeExpr(elemAccessor, &elem.Type, registry, depth+1, ctx))
	}

	parts = append(parts, "\"]\"")
	return strings.Join(parts, " + ")
}

func generateSerializeNative(accessor string, meta *metadata.Metadata) string {
	switch meta.NativeType {
	case "Date":
		return fmt.Sprintf("\"\\\"\" + %s.toISOString() + \"\\\"\"", accessor)
	default:
		return fmt.Sprintf("JSON.stringify(%s)", accessor)
	}
}
