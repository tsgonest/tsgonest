import { join, dirname } from 'path';
import { existsSync, readFileSync } from 'fs';

/**
 * Route mapping entry — maps a controller method to its return type.
 * Key format in the manifest: "ControllerName.methodName"
 */
export interface RouteMapping {
  /** The DTO type name (e.g., "UserResponse"). */
  returnType: string;
  /** Whether the method returns an array of the return type. */
  isArray?: boolean;
}

/**
 * The manifest file generated by tsgonest during compilation.
 * Maps DTO type names to their companion file paths and function names.
 */
export interface TsgonestManifest {
  validators: Record<string, ManifestEntry>;
  serializers: Record<string, ManifestEntry>;
  routes?: Record<string, RouteMapping>;
}

/**
 * A single entry in the manifest, pointing to a companion file and exported function.
 */
export interface ManifestEntry {
  /** Relative path to the companion JS file. */
  file: string;
  /** Name of the exported function in the companion file. */
  fn: string;
}

/**
 * Loaded validator/serializer function cache.
 */
interface FunctionCache {
  validators: Map<string, (input: unknown) => unknown>;
  serializers: Map<string, (input: unknown) => string>;
}

/**
 * Discovers and loads companion file functions from the tsgonest manifest.
 */
export class CompanionDiscovery {
  private manifest: TsgonestManifest | null = null;
  private manifestDir: string = '';
  private cache: FunctionCache = {
    validators: new Map(),
    serializers: new Map(),
  };

  /**
   * Load the manifest from a directory.
   * Searches for __tsgonest_manifest.json in the given directory.
   */
  loadManifest(distDir: string): boolean {
    const manifestPath = join(distDir, '__tsgonest_manifest.json');
    if (!existsSync(manifestPath)) {
      return false;
    }

    try {
      const content = readFileSync(manifestPath, 'utf-8');
      this.manifest = JSON.parse(content) as TsgonestManifest;
      this.manifestDir = dirname(manifestPath);
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Load the manifest from a JSON string.
   * Used for testing or when the manifest is embedded.
   */
  loadManifestFromJSON(json: string, baseDir: string): boolean {
    try {
      this.manifest = JSON.parse(json) as TsgonestManifest;
      this.manifestDir = baseDir;
      return true;
    } catch {
      return false;
    }
  }

  /**
   * Get a validator function for a DTO type name.
   * Returns the assert function that throws on invalid input.
   */
  getValidator(typeName: string): ((input: unknown) => unknown) | null {
    // Check cache
    const cached = this.cache.validators.get(typeName);
    if (cached) return cached;

    if (!this.manifest) return null;
    const entry = this.manifest.validators[typeName];
    if (!entry) return null;

    try {
      const filePath = join(this.manifestDir, entry.file);
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const mod = require(filePath);
      const fn = mod[entry.fn];
      if (typeof fn === 'function') {
        this.cache.validators.set(typeName, fn);
        return fn;
      }
    } catch {
      // Failed to load companion file
    }

    return null;
  }

  /**
   * Get a serializer function for a DTO type name.
   * Returns a function that converts the input to a JSON string.
   */
  getSerializer(typeName: string): ((input: unknown) => string) | null {
    // Check cache
    const cached = this.cache.serializers.get(typeName);
    if (cached) return cached;

    if (!this.manifest) return null;
    const entry = this.manifest.serializers[typeName];
    if (!entry) return null;

    try {
      const filePath = join(this.manifestDir, entry.file);
      // eslint-disable-next-line @typescript-eslint/no-var-requires
      const mod = require(filePath);
      const fn = mod[entry.fn];
      if (typeof fn === 'function') {
        this.cache.serializers.set(typeName, fn);
        return fn;
      }
    } catch {
      // Failed to load companion file
    }

    return null;
  }

  /**
   * Check if a validator exists for a type.
   */
  hasValidator(typeName: string): boolean {
    return this.manifest?.validators[typeName] != null;
  }

  /**
   * Check if a serializer exists for a type.
   */
  hasSerializer(typeName: string): boolean {
    return this.manifest?.serializers[typeName] != null;
  }

  /**
   * Get all registered validator type names.
   */
  getValidatorTypes(): string[] {
    return this.manifest ? Object.keys(this.manifest.validators) : [];
  }

  /**
   * Get all registered serializer type names.
   */
  getSerializerTypes(): string[] {
    return this.manifest ? Object.keys(this.manifest.serializers) : [];
  }

  /**
   * Look up the return type for a controller method from the route map.
   * @param controllerName The controller class name (e.g., "UserController").
   * @param methodName The method name (e.g., "findAll").
   * @returns The route mapping or null if not found.
   */
  getRouteMapping(controllerName: string, methodName: string): RouteMapping | null {
    if (!this.manifest?.routes) return null;
    const key = `${controllerName}.${methodName}`;
    return this.manifest.routes[key] ?? null;
  }

  /**
   * Get a serializer function for a controller method, using the route map.
   * This is the primary lookup path for the fast interceptor — no Reflect metadata needed.
   * @returns An object with the serializer function and whether it's an array, or null.
   */
  getSerializerForRoute(
    controllerName: string,
    methodName: string,
  ): { serializer: (input: unknown) => string; isArray: boolean } | null {
    const mapping = this.getRouteMapping(controllerName, methodName);
    if (!mapping) return null;

    const serializer = this.getSerializer(mapping.returnType);
    if (!serializer) return null;

    return { serializer, isArray: mapping.isArray ?? false };
  }
}
